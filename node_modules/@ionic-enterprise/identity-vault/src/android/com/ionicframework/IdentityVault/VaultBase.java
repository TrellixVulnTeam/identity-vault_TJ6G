package com.ionicframework.IdentityVault;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;

import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import androidx.arch.core.util.Function;

import org.json.JSONObject;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;

import javax.crypto.Cipher;

@RequiresApi(api = Build.VERSION_CODES.M)
abstract class VaultBase {
    protected final AppCompatActivity activity;
    public final IdentityVaultConfig config;
    protected Function<Void, Void> onLockCallback;
    protected Function<Void, Void> onUnlockCallback;
    protected HashMap<String, String> data;
    protected String customPasscode;
    protected int allowedInvalidUnlockAttempts = 0;
    protected Date backgroundEnteredAt;

    abstract protected String getVaultType();

    public VaultBase(IdentityVaultConfig config, AppCompatActivity activity) {
        this.config = config;
        this.activity = activity;
    }

    public static String getPersistedVaultType(IdentityVaultConfig config, AppCompatActivity activity) throws VaultError {
        SharedPreferences pref = activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
        return pref.getString("vaultType", null);
    }

    public static String getPersistedVaultDeviceSecurityType(IdentityVaultConfig config, AppCompatActivity activity) {
        SharedPreferences pref = activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
        return pref.getString("vaultDeviceSecurityType", null);
    }

    public void clear() throws VaultError {
        this.clearStoredData();
        this.lock();
    }

    public void clearTypes() throws VaultError {
        try {
            SharedPreferences pref = this.activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = pref.edit();
            editor.remove("vaultType");
            editor.remove("vaultDeviceSecurityType");
            editor.apply();
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    public boolean doesVaultExist() {
        return this.checkIfVaultExists();
    }

    public HashMap<String, String> exportVault() throws VaultError {
        this.unlock();
        return this.data;
    }

    public String[] getKeys() throws VaultError {
        if (!this.doesVaultExist()) { return null; }
        this.unlock();
        return this.data.keySet().toArray(new String[0]);
    }

    public String getValue(String key) throws VaultError {
        if (!this.doesVaultExist()) { return null; }
        this.unlock();
        return this.data.get(key);
    }

    public void importVault(HashMap<String, String> data) throws VaultError {
        this.unlock();
        this.data = data;
        this.storeData();
    }

    public boolean isLocked() {
        return this.data == null;
    }

    public void lock() {
        if (!this.isLocked() && this.doesVaultExist()) {
            this.data = null;
            this.customPasscode = null;

            if (this.onLockCallback != null) {
                this.onLockCallback.apply(null);
            }
        }
    }

    public void requestBiometricPrompt() throws VaultError {
        throw new SecurityNotAvailableError();
    }

    public void removeValue(String key) throws VaultError {
        this.unlock();
        this.data.remove(key);
        this.storeData();
    }

    public void setCustomPasscode(String passcode) {
        this.customPasscode = passcode;
    }

    public void setValue(String key, String value) throws VaultError {
        this.unlock();
        this.data.put(key, value);
        this.storeData();
    }

    public void unlock() throws VaultError {
        this.unlock(true);
    }

    public void unlock(boolean forceUnlock) throws VaultError {
        if (this.isLocked()) {
            if(this.doesVaultExist() || forceUnlock) {
                this.getData();
                if (this.onUnlockCallback != null) {
                    this.onUnlockCallback.apply(null);
                }
            }
        }
    }

    public void onUnlock(Function<Void, Void> callback) {
        this.onUnlockCallback = callback;
    }

    public void onLock(Function<Void, Void> callback) {
        this.onLockCallback = callback;
    }

    protected void appLaunched() throws VaultError {
        if (this.config.unlockVaultOnLoad) {
            this.unlock(false);
        }
    }

    protected void appResumed() throws VaultError {
        try {
            if (this.config.lockAfterBackgrounded != null && this.backgroundEnteredAt != null) {
                long elapsed = Math.abs(new Date().getTime() - this.backgroundEnteredAt.getTime());
                if (elapsed >= this.config.lockAfterBackgrounded) {
                    this.lock();
                }
            }

            this.backgroundEnteredAt = null;

            if (this.isLocked() && this.config.unlockVaultOnLoad) {
                this.unlock(false);
            }
        } catch (VaultError e) {
            throw e;
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    protected void backgroundEntered() {
        if (this.config.lockAfterBackgrounded != null) {
            this.backgroundEnteredAt = new Date();
        }
    }

    private boolean checkIfVaultExists() {
        //todo: should we check existence of key as well?
        if (!this.isLocked()) {
            return true;
        }
        SharedPreferences pref = this.activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
        return pref.contains("data");
    }

    protected void clearStoredData() throws VaultError {
        try {
            SharedPreferences pref = this.activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = pref.edit();
            editor.remove("data");
            editor.remove("vaultType");
            editor.remove("vaultDeviceSecurityType");
            editor.apply();
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    protected void getData() throws VaultError {
        try {
            if (this.data == null) {
                data = new HashMap<>();
                SharedPreferences pref = this.activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
                String encryptedJsonString = pref.getString("data", null);

                if (encryptedJsonString != null) {
                    String passcode = this instanceof DeviceSecurityStrongVault ? ((DeviceSecurityStrongVault) this).masterPasscode : this.customPasscode;
                    String decryptedJsonString = CryptoData.decrypt("iv:" + config.key, encryptedJsonString, passcode);
                    JSONObject jsonObject = new JSONObject(decryptedJsonString);
                    for (Iterator<String> it = jsonObject.keys(); it.hasNext(); ) {
                        String key = it.next();
                        String value = jsonObject.getString(key);
                        this.data.put(key, value);
                    }
                } else {
                    this.storeData();
                }

                this.setFailedUnlockAttempts(0);
            }
        } catch (AuthFailedError e) {
            this.lock();
            int failedUnlockAttempts = this.getFailedUnlockAttempts();
            failedUnlockAttempts += 1;
            if(failedUnlockAttempts >= this.allowedInvalidUnlockAttempts) {
                this.clear();
                this.setFailedUnlockAttempts(0);
                throw new TooManyFailedAttemptsError();
            }
            this.setFailedUnlockAttempts(failedUnlockAttempts);
            throw e;
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    private void storeData() throws VaultError {
        try {
            JSONObject dataJsonObject = new JSONObject(this.data);
            String dataJsonString = dataJsonObject.toString();
            String passcode = this instanceof DeviceSecurityStrongVault ? ((DeviceSecurityStrongVault) this).masterPasscode : this.customPasscode;
            String encryptedDataJson = CryptoData.encrypt("iv:" + config.key, dataJsonString, passcode);
            String vaultType = this.getVaultType();

            SharedPreferences pref = this.activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = pref.edit();
            editor.putString("data", encryptedDataJson);
            editor.putString("vaultType", vaultType);
            editor.putString("vaultDeviceSecurityType", config.deviceSecurityType);
            editor.apply();
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    private int getFailedUnlockAttempts() {
        SharedPreferences pref = this.activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
        return pref.getInt("unlockAttempts", 0);
    }

    private void setFailedUnlockAttempts(int failedUnlockAttempts) {
        SharedPreferences pref = this.activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = pref.edit();
        editor.putInt("unlockAttempts", failedUnlockAttempts);
        editor.apply();
    }
}
