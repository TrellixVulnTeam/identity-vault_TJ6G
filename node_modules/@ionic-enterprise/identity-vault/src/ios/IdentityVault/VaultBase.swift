import Foundation
import LocalAuthentication

class VaultBase {
    
    internal var data: [String: String]?
    internal var accessControl: SecAccessControl?
    internal var authContext: LAContext?
    
    internal var customPasscode: String?
    internal var config: IdentityVaultConfig
    private var backgroundEnteredTime: Date?
    internal var allowedInvalidUnlockAttempts: Int32 = 0
    
    internal var onLockCallback: (() -> ())?
    internal var onUnlockCallback: (() -> ())?
    
    internal var vaultType: String? {
        return nil
    }
    
    init(_ config: IdentityVaultConfig) throws {
        self.config = config
    }
    
    func clear() throws {
        try clearData()
        try clearVaultType()
        try clearVaultDeviceSecurityType();
        self.data = nil
        self.customPasscode = nil
    }
    
    func doesVaultExist() throws -> Bool {
        return try self.checkIfVaultExists()
    }
    
    func exportVault() throws -> [String: String]? {
        try unlock()
        return self.data
    }
    
    func lock() throws {
        if !self.isLocked() {
            if  try self.doesVaultExist() {
                self.data = nil
                self.customPasscode = nil
                if self.onLockCallback != nil {
                    self.onLockCallback!()
                }
            }
        }
    }
    
    func getKeys() throws -> [String] {
        if try !self.doesVaultExist() {
            return []
        }
        try unlock()
        return Array(self.data!.keys)
    }
    
    func isLocked() -> Bool {
        return self.data == nil
    }
    
    func importVault(_ data: [String: String]) throws {
        try unlock()
        self.data = data
        try storeData()
    }
    
    func getValue(_ key: String) throws -> String? {
        if try !self.doesVaultExist() {
            return nil
        }
        try unlock()
        let value = self.data?[key]
        return value
    }
    
    func setCustomPasscode(_ passcode: String) {
        self.customPasscode = passcode
    }
    
    func setValue(_ key: String, _ value: String?) throws {
        try unlock()
        self.data![key] = value
        try storeData()
    }
    
    func onLock(_ callback: @escaping () -> ()) {
        self.onLockCallback = callback
    }
    
    func onUnlock(_ callback: @escaping () -> ()) {
        self.onUnlockCallback = callback
    }
    
    static public func getPersistedVaultType(key: String) throws -> String? {
        let query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: "\(key)_vaultType".data(using: .utf8)!,
            kSecMatchLimit: 1,
            kSecReturnAttributes: true,
            kSecReturnData: true
        ] as Dictionary
        
        var queryResult: AnyObject?
                    
        let status = SecItemCopyMatching(query as CFDictionary, &queryResult)
        guard status != errSecItemNotFound else {
            return nil
        }
        guard status == noErr else { throw VaultError.unhandledError(status.description) }
        
        let rawData = queryResult![kSecValueData] as! Data
        return String(data: rawData, encoding: .utf8)
    }
    
    static public func getPersistedVaultDeviceSecurityType(key: String) throws -> String? {
        let query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: "\(key)_vaultDeviceSecurityType".data(using: .utf8)!,
            kSecMatchLimit: 1,
            kSecReturnAttributes: true,
            kSecReturnData: true
        ] as Dictionary
        
        var queryResult: AnyObject?
                    
        let status = SecItemCopyMatching(query as CFDictionary, &queryResult)
        guard status != errSecItemNotFound else {
            return nil
        }
        guard status == noErr else { throw VaultError.unhandledError(status.description) }
        
        let rawData = queryResult![kSecValueData] as! Data
        return String(data: rawData, encoding: .utf8)
    }
    
    public func removeValue(_ key: String) throws {
        try unlock()
        self.data!.removeValue(forKey: key)
        try storeData()
    }
    
    func unlock(_ forceUnlock: Bool = true) throws {
        if self.isLocked() {
            if try self.doesVaultExist() || forceUnlock {
                try getData()
                if self.onUnlockCallback != nil {
                    self.onUnlockCallback!()
                }
            }
        }
    }
    
    internal func appLaunched() throws {
        if self.config.unlockVaultOnLoad == true {
            try self.unlock(false)
        }
    }
    
    internal func appResumed() throws {
        if self.config.lockAfterBackgrounded != nil && self.backgroundEnteredTime != nil {
            let elapsed = Date().timeIntervalSince(self.backgroundEnteredTime!) * 1000
            
            if !elapsed.isLessThanOrEqualTo(Double(self.config.lockAfterBackgrounded!)) {
                try self.lock()
            }
        }
        self.backgroundEnteredTime = nil
        if self.isLocked() && self.config.unlockVaultOnLoad == true {
            try self.unlock(false)
        }
    }
    
    internal func backgroundEntered() {
        if self.config.lockAfterBackgrounded != nil {
            self.backgroundEnteredTime = Date()
        }
    }
    
    private func checkIfVaultExists() throws -> Bool {
        if !self.isLocked() {
            return true
        }
        let query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: self.config.key.data(using: .utf8)!,
            kSecUseAuthenticationUI as AnyHashable: kSecUseAuthenticationUIFail
        ] as Dictionary
        
        let status = SecItemCopyMatching(query as CFDictionary, nil)
        
        switch status {
        case errSecItemNotFound:
            return false
        case noErr:
            return true
        case errSecInteractionNotAllowed:
            // If errSecInteractionNotAllowed, the key is present, but we aren't allowed to access it without auth
            return true
        case errSecAuthFailed:
            if !Device().isBiometricsSupported {
               throw VaultError.biometricsNotEnabled
            }
            
            if Device().isLockedOut {
                throw VaultError.biometricsLockedOut
            }
            
            throw VaultError.authFailed
        default:
            throw VaultError.unhandledError(status.description)
        }
    }
    
    private func getData() throws {
        if self.data == nil {
            defer {
                if Device.isShowingBiometrics {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                        Device.isShowingBiometrics = false
                    }
                }
            }

            var query = [
                kSecClass: kSecClassGenericPassword,
                kSecAttrService: self.config.key.data(using: .utf8)!,
                kSecMatchLimit: 1,
                kSecReturnAttributes: true,
                kSecReturnData: true
            ] as Dictionary
            
            if self.accessControl != nil {
                query[kSecAttrAccessControl] = self.accessControl as Any
            }
            
            if self.authContext != nil {
                query[kSecUseAuthenticationContext] = self.authContext
            }          
            
            var queryResult: AnyObject?
            
            if self.customPasscode == nil {
                Device.isShowingBiometrics = true
            }
                        
            let status = SecItemCopyMatching(query as CFDictionary, &queryResult)
            
            switch status {
            case errSecItemNotFound:
                self.data = [:]
                try self.storeData()
                return
            case errSecAuthFailed:
                self.data = nil
                self.customPasscode = nil
                
                if !Device().isBiometricsSupported {
                   throw VaultError.biometricsNotEnabled
                }
                
                if Device().isLockedOut {
                    throw VaultError.biometricsLockedOut
                }
                
                var failedUnlockAttempts = try self.getFailedUnlockAttempts()
                failedUnlockAttempts += 1
                
                if self.config.shouldClearVaultAfterTooManyFailedAttempts ?? false {
                    if failedUnlockAttempts >= self.allowedInvalidUnlockAttempts {
                        try self.clear()
                        try self.setFailedUnlockAttempts(attempts: 0)
                        
                        throw VaultError.tooManyFailedAttempts
                    }
                }
                
                try self.setFailedUnlockAttempts(attempts: failedUnlockAttempts)
                throw VaultError.authFailed
            case errSecUserCanceled:
                throw VaultError.userCanceledAuth
            case noErr:
                try self.setFailedUnlockAttempts(attempts: 0)
                let rawData = queryResult![kSecValueData] as! Data
                
                self.data = try JSONSerialization.jsonObject(with: rawData, options: []) as? [String: String] ?? [:]
            default:
                print("unknown error: \(status.description)")
                throw VaultError.unhandledError(status.description)
                
            }
            
        }
    }
    
    private func storeVaultType() throws {
        try clearVaultType()
        
        let vaultType = self.vaultType ?? ""
        
        let query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: "\(self.config.key)_vaultType".data(using: .utf8)!,
            kSecValueData: vaultType.data(using: .utf8)!
        ] as Dictionary
        
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status != errSecNotAvailable else { throw VaultError.securityNotAvailable }
        guard status == noErr else {
            throw VaultError.unhandledError(status.description)
        }
    }
    
    private func storeVaultDeviceSecurityType() throws {
        try clearVaultDeviceSecurityType()
        
        let vaultDST = self.config.deviceSecurityType
        
        let query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: "\(self.config.key)_vaultDeviceSecurityType".data(using: .utf8)!,
            kSecValueData: vaultDST.data(using: .utf8)!
        ] as Dictionary
        
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status != errSecNotAvailable else { throw VaultError.securityNotAvailable }
        guard status == noErr else {
            throw VaultError.unhandledError(status.description)
        }
    }
    
    private func storeData() throws {
        try storeVaultType()
        try storeVaultDeviceSecurityType()
        
        try clearData()
        
        let jsonData = try JSONSerialization.data(withJSONObject: self.data ?? "")
        let jsonString = String(data: jsonData, encoding: .utf8) ?? ""

        var query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: self.config.key.data(using: .utf8)!,
            kSecValueData: (jsonString).data(using: .utf8)!
        ] as Dictionary
        
        if self.accessControl != nil {
            query[kSecAttrAccessControl] = self.accessControl as Any
        }
        
        if self.authContext != nil {
            query[kSecUseAuthenticationContext] = self.authContext
        }
        
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status != errSecNotAvailable else { throw VaultError.securityNotAvailable }
        guard status != errSecAuthFailed  else { throw VaultError.securityNotAvailable }
        guard status != errSecAuthFailed else {
            self.data = nil
            self.customPasscode = nil
            throw VaultError.authFailed
        }
        guard status == noErr else {
            throw VaultError.unhandledError(status.description)
        }
    }
    
    private func clearVaultType() throws {
        let query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: "\(self.config.key)_vaultType".data(using: .utf8)!
        ] as Dictionary
        
        let status = SecItemDelete(query as CFDictionary)
        
        guard status == noErr || status == errSecItemNotFound else { throw VaultError.unhandledError(status.description) }
    }
    
    private func clearVaultDeviceSecurityType() throws {
        let query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: "\(self.config.key)_vaultDeviceSecurityType".data(using: .utf8)!
        ] as Dictionary
        
        let status = SecItemDelete(query as CFDictionary)
        
        guard status == noErr || status == errSecItemNotFound else { throw VaultError.unhandledError(status.description) }
    }
    
    private func clearData() throws {
        var query = [
            kSecClass: kSecClassGenericPassword,
            kSecAttrService: config.self.key.data(using: .utf8)!,
        ] as Dictionary
        
        if self.accessControl != nil {
            query[kSecAttrAccessControl] = self.accessControl as Any
        }
        
        if self.authContext != nil {
            query[kSecUseAuthenticationContext] = self.authContext
        }
        
        let status = SecItemDelete(query as CFDictionary)
        
        guard status == noErr || status == errSecItemNotFound else { throw VaultError.unhandledError(status.description) }        
    }
    
    private func getApplicationSupportDirectory() -> URL? {
        guard let directory = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first else {
            return nil
        }
        
        
        if !FileManager.default.fileExists(atPath: directory.path) {
            do {
                try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: false, attributes: nil)
            } catch {
               print(error)
            }
        }
        
        return directory
    }
    
    private func getFailedUnlockAttempts() throws -> Int {        
        let attempts = UserDefaults.standard.integer(forKey: "\(config.key)_unlockAttempts")
        return attempts
    }
    
    private func setFailedUnlockAttempts(attempts: Int) throws {
        UserDefaults.standard.set(attempts, forKey: "\(config.key)_unlockAttempts")
    }
}


