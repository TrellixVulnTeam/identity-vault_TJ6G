import { VaultError } from "./definitions";
import { IdentityVaultConfig } from "./IdentityVaultConfig";
import { VaultInterface } from "./VaultInterface";
/**
 * Represents a vault for secure value storage
 */
export declare class Vault implements VaultInterface {
    /** @ignore */
    private passCodeRequestedCallback?;
    /** @ignore */
    private defaultConfig;
    /** @ignore */
    config: IdentityVaultConfig;
    /**
     * @usage
     * ```typescript
     * const vault = new Vault({
     *  key: 'com.company.myvaultapp',
     *  type: 'CustomPasscode',
     *  deviceSecurityType: DeviceSecurityType.None,
     *  lockAfterBackgrounded: 2000,
     * });
     * ```
     * @param config
     */
    constructor(config: IdentityVaultConfig);
    /**
     * Resolves true if a vault with the same key already exists, and false if not.
     * The vault does not need to be unlocked to check.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const vaultExists = await vault.doesVaultExists()
     * if (!vaultExists) {
     *  // the vault does not exist...
     * }
     * ```
     */
    doesVaultExist(): Promise<boolean>;
    /**
     * Clears out the current vault and removes it from the system.
     * Note: The vault does not need to be unlocked in order to clear it. No credentials are checked
     * when clearing the vault.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.clear();
     * ```
     */
    clear(): Promise<void>;
    /**
     * Exports the data of the current vault in its entirety.
     * The data is a map with keys that are strings and values that are JSON.
     * Calling `exportVault` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const data = await vault.exportVault();
     * ```
     *
     * @return The resolved object is a map with string keys and string values.
     *
     */
    exportVault(): Promise<{
        [key: string]: string;
    }>;
    /**
     * Imports data into the vault, replacing the current contents of the vault.
     * The data is a map with keys that are strings and values that are JSON.
     * Calling `importVault` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const dataFromElsewhere = await getUserData();
     * const newVault = new Vault(vaultConfig);
     * await newVault.importVault(dataFromElsewhere);
     * ```
     *
     * @param data The entire data object to be imported. The shape of data must be {[key: string]: string}.
     *
     */
    importVault(data: {
        [key: string]: string;
    }): Promise<void>;
    /**
     * Checks if the vault is currently in a locked state, which signifies that the contents
     * of the secure vault are not currently accessible. `isLocked` can also return true if the
     * vault does not exist.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const locked = await vault.isLocked();
     * if (locked) {
     *  // vault is locked (or does not exist);
     * }
     * ```
     */
    isLocked(): Promise<boolean>;
    /**
     * Returns an array of keys that are currently in the vault.
     * Calling `getKeys` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const allKeys = await vault.getKeys();
     * allKeys.forEach((key) => {
     *  // do something with the key
     * });
     * ```
     */
    getKeys(): Promise<string[]>;
    /**
     * Gets the value for a given key. Returns null if the key does not exist.
     * Calling `getValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const userFirstName = await vault.getValue<string>("firstname");
     * ```
     *
     * @param key The key to look up the value for
     *
     */
    getValue<T = any>(key: string): Promise<T | null>;
    /**
     * Locks the vault if it is currently unlocked.
     * Locking the vault with remove all secure data from memory inside of Identity Vault, but not your application.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.lock();
     * ```
     */
    lock(): Promise<void>;
    /**
     * Removes a value from the vault.
     * Calling `removeValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.removeValue("address");
     * ```
     *
     * @param key The key to remove
     *
     */
    removeValue(key: string): Promise<void>;
    /**
     * When the vault type is set to 'CustomPasscode', this method sets the passcode required to
     * secure the vault.
     * This method is typically called in the `onPasscodeRequested` callback.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const code = window.prompt("Enter your passcode.");
     * if (code) {
     *  await vault.setCustomPasscode(code);
     * }
     * ```
     *
     * @param passcode The user supplied passcode to secure the vault with.
     *
     */
    setCustomPasscode(passcode: string): Promise<void>;
    /**
     * Sets the value of an item in the vault.
     * Calling `setValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.setValue<string>("theme", theme);
     * ```
     *
     * @param key The key for the new value.
     * @param value The value to store in the vault. Value can be of any type, as it will be parsed to JSON in the vault.
     *
     */
    setValue<T = any>(key: string, value: T): Promise<void>;
    /**
     * Triggers when a config change occurs.
     *
     * @usage
     * ```typescript
     * vault.onConfigChanged((config) => {
     *  console.log("updated config: ", config);
     * });
     * ```
     * @param callback The callback function that will be called when the event triggers. Passes in the current vault config.
     *
     */
    onConfigChanged(callback: (config: IdentityVaultConfig) => void): void;
    /**
     * Triggers when an error occurs in the application.
     * Errors that come back as rejected promises also trigger this event.
     *
     * @usage
     * ```typescript
     * vault.onError((err) => {
     *  console.log('ERROR from callback', JSON.stringify(err));
     * });
     * ```
     *
     * @param callback The callback function that will be called when the event triggers. Passes in the error object.
     *
     */
    onError(callback: (err: VaultError) => void): void;
    /**
     * Triggers when the vault enters a locked state.
     *
     * @usage
     * ```typescript
     * vault.onLock(() => { displayNotification("Vault locked."); })
     * ```
     *
     * @param callback The callback function that will be called when the event triggers.
     *
     */
    onLock(callback: () => void): void;
    /**
     * For CustomPasscode vaults, this event triggers when the vault is attempting to unlock
     * and the passcode has not been set yet. The callback function will pass in a Promise that,
     * when resolved, with attempt to unlock the vault again calling the same method that originally
     * tried to unlock the vault. Before the promise is resolved, you should prompt the user to supply a passcode, and
     * then supply that value to `setCustomPasscode`.
     *
     * @usage
     * ```typescript
     * vault.onPasscodeRequested(async (isPasscodeSetRequest) => {
     *  const message = isPasscodeSetRequest
     *    ? 'Setup Passcode' // passcode is being set for first time
     *    : 'Enter passcode'; // passcode is being asked for unlock
     *  const passcode = window.prompt(message) || '';
     *   vault.setCustomPasscode(passcode);
     *   return Promise.resolve();
     * });
     * ```
     *
     * @param callback The callback function that will be called when the event triggers. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.
     *
     */
    onPasscodeRequested(callback: (isPasscodeSetRequest: boolean) => Promise<void>): void;
    /**
     * Triggers when the vault enters an unlocked state.
     *
     * @usage
     * ```typescript
     * vault.onUnlock(() => {
     *  console.log("vault is now unlocked");
     * });
     * ```
     * @param callback The callback function that will be called when the event triggers.
     *
     */
    onUnlock(callback: () => void): void;
    /**
     * Manually unlock the vault. Will trigger any authentication mechanism needed to access the vault (passcode, biometrics, etc..).
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.unlock();
     * ```
     */
    unlock(): Promise<void>;
    /**
     * Updates the configuration of the current vault.
     *
     *  @usage
     * ```typescript
     * async function changeVaultType(type: VaultType) {
     *  const vault = new Vault(this.existingVaultConfig);
     *  const newConfig = { ...this.existingVaultConfig, type };
     *  await vault.updateConfig(newConfig);
     *  this.existingVaultConfig = newConfig;
     * }
     * ```
     *
     * @param config The new config
     *
     */
    updateConfig(config: IdentityVaultConfig): Promise<void>;
    /** @ignore */
    private handleError;
    /** @ignore */
    requestBiometricPrompt(): Promise<boolean>;
    /**
     * @ignore
     */
    private resume;
    /**
     * @ignore
     */
    private setup;
    /**
     * @ignore
     */
    private getPersistedVaultConfig;
}
