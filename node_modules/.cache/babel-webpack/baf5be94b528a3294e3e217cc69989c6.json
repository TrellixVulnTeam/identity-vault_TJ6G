{"ast":null,"code":"import _asyncToGenerator from \"/Users/i711243/Desktop/projects/Duplicate_Projects/Identity_vault/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/*! Ionic Enterprise Identity Vault: https://ionicframework.com/ - Commercially Licensed */\n\n/**\n * The meaning of the error code in the thrown {@link VaultError}.\n */\nvar VaultErrorCodes;\n\n(function (VaultErrorCodes) {\n  /**\n   * An unknown error happened.\n   * @constant `0`\n   */\n  VaultErrorCodes[VaultErrorCodes[\"Unknown\"] = 0] = \"Unknown\";\n  /**\n   * The operation failed because the vault was locked.\n   * @constant `1`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"VaultLocked\"] = 1] = \"VaultLocked\";\n  /**\n   * The operation failed because the vault was unavailable.\n   * The most likely cause of this error is that a vault has not been configured.\n   * @constant `2`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"VaultUnavailable\"] = 2] = \"VaultUnavailable\";\n  /**\n   * The operation failed because the some of the vault provided arguments were invalid.\n   * @constant `3`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"InvalidArguments\"] = 3] = \"InvalidArguments\";\n  /**\n   * The credentials were invalidated. This can happen when a user changes biometrics or passcode.\n   * @constant `4`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"InvalidatedCredential\"] = 4] = \"InvalidatedCredential\";\n  /**\n   * Biometric security is unavailable due to a passcode not being set up at the system level.\n   * In order to use biometric identification on the device a system level passcode must be set up by the user.\n   * @constant `5`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"SecurityNotAvailable\"] = 5] = \"SecurityNotAvailable\";\n  /**\n   * User authentication failed.\n   * @constant `6`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"AuthFailed\"] = 6] = \"AuthFailed\";\n  /**\n   * Too many failed authentication attempts made against the custom passcode vault, so the vault was cleared and user will need to login again.\n   * @constant `7`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"TooManyFailedAttempts\"] = 7] = \"TooManyFailedAttempts\";\n  /**\n   * The user cancelled the native authentication dialog.\n   *\n   * **Note**: On iOS, this error code will also be thrown in the event that the native authentication dialog fails as a result of too many failed attempts.\n   * The user will be forced to cancel the dialog, triggering this error code.\n   *\n   * On Android, this error also will be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both} in the event of too many failed attempts.\n   * Its currently not possible to get the nature of failures from the native authentication dialog, and similar to iOS, the user will be forced to cancel the dialog, triggering this error code.\n   * @constant `8`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"UserCanceledInteraction\"] = 8] = \"UserCanceledInteraction\";\n  /**\n   * The user provided mismatched passcodes.\n   * @constant `9`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"MismatchedPasscode\"] = 9] = \"MismatchedPasscode\";\n  /**\n   * The operation requires passcode to be setup but it isn't set yet. Call {@link Vault.setCustomPasscode} to set it.\n   * @constant `10`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"MissingPasscode\"] = 10] = \"MissingPasscode\";\n  /**\n   * The operation failed because the application tried to unlock the vault with passcode authentication,\n   * but the vault is not configured to allow passcode authentication.\n   * @constant `11`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"PasscodeNotEnabled\"] = 11] = \"PasscodeNotEnabled\";\n  /**\n   * The key was not found. This can happen when a user changes biometrics or passcode.\n   * @constant `12`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"KeyNotFound\"] = 12] = \"KeyNotFound\";\n  /**\n   * The operation failed because biometric authentication is not enabled.\n   * This can occur when biometrics is not supported by the device\n   * or when biometrics has not been configured for the device or vault.\n   * @constant `13`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"BiometricsNotEnabled\"] = 13] = \"BiometricsNotEnabled\";\n  /**\n   * @ignore\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"InvalidAuthMode\"] = 14] = \"InvalidAuthMode\";\n  /**\n   * Biometrics have not been authed yet (Android only)\n   * @constant `15`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"MissingBiometrics\"] = 15] = \"MissingBiometrics\";\n  /**\n   * {@link DeviceSecurityType.SystemPasscode} for {@link DeviceSecurityType} not available on this Android device.\n   * @constant `16`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"AndroidSystemPasscodeUnavailable\"] = 16] = \"AndroidSystemPasscodeUnavailable\";\n  /**\n   * Biometrics have been locked out, usually because of too many failed attempts.\n   *\n   * **Note:** This error will never be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both}.\n   * Its currently not possible to get the nature of failures from the native authentication dialog, so the only error that would be thrown is {@link VaultErrorCodes.UserCanceledInteraction} as the user\n   * is forced to cancel the prompt.\n   *\n   * @constant `17`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"AndroidBiometricsLockedOut\"] = 17] = \"AndroidBiometricsLockedOut\";\n  /**\n   * Biometrics have been locked out, usually because of too many failed attempts.\n   *\n   * @constant `18`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"iOSBiometricsLockedOut\"] = 18] = \"iOSBiometricsLockedOut\";\n  /**\n   * An unexpected error has occurred in the Android keystore.\n   *\n   * @constant `19`\n   */\n\n  VaultErrorCodes[VaultErrorCodes[\"AndroidUnexpectedKeystoreError\"] = 19] = \"AndroidUnexpectedKeystoreError\";\n})(VaultErrorCodes || (VaultErrorCodes = {}));\n/**\n * The possible values returned by {@link Device.getAvailableHardware}\n */\n\n\nvar SupportedBiometricType;\n\n(function (SupportedBiometricType) {\n  /** The device supports fingerprint scanning. */\n  SupportedBiometricType[\"Fingerprint\"] = \"fingerprint\";\n  /** The device supports facial recognition. */\n\n  SupportedBiometricType[\"Face\"] = \"face\";\n  /** The device supports iris scanning. */\n\n  SupportedBiometricType[\"Iris\"] = \"iris\";\n})(SupportedBiometricType || (SupportedBiometricType = {}));\n/**\n * Possible device biometric strength levels on Android (always `strong` on iOS).\n * [More Information](https://source.android.com/security/biometric/measure#tiered-authentication).\n */\n\n\nvar BiometricSecurityStrength;\n\n(function (BiometricSecurityStrength) {\n  /** Refers to Class 2 - Weak biometric security */\n  BiometricSecurityStrength[\"Weak\"] = \"weak\";\n  /** Refers to Class 3 - Strong biometric security */\n\n  BiometricSecurityStrength[\"Strong\"] = \"strong\";\n})(BiometricSecurityStrength || (BiometricSecurityStrength = {}));\n/**\n * When type is set to 'DeviceSecurity', determines which aspects of the device to use to secure the vault.\n * Note: Android only supports `SystemPasscode` on Android 11 and greater.\n * @default `Both`\n */\n\n\nvar DeviceSecurityType;\n\n(function (DeviceSecurityType) {\n  /** Will allow a system passcode to secure the vault. On Android, only supported on Android 11 and greater. */\n  DeviceSecurityType[\"SystemPasscode\"] = \"SystemPasscode\";\n  /** WIll allow biometric hardware tos secure the vault. */\n\n  DeviceSecurityType[\"Biometrics\"] = \"Biometrics\";\n  /** WIll allow both SystemPasscode or Biometrics as an option to secure the vault. */\n\n  DeviceSecurityType[\"Both\"] = \"Both\";\n  /** No biometric security option will be used. */\n\n  DeviceSecurityType[\"None\"] = \"None\";\n})(DeviceSecurityType || (DeviceSecurityType = {}));\n/**\n * The type of vault\n */\n\n\nvar VaultType;\n\n(function (VaultType) {\n  /** No additional security is required in the app as long as the device was unlocked with a secure method. */\n  VaultType[\"SecureStorage\"] = \"SecureStorage\";\n  /** Uses additional device features to add an additional layer of security while the user is in the app. */\n\n  VaultType[\"DeviceSecurity\"] = \"DeviceSecurity\";\n  /** User will set a custom passcode that will be used to access the vault. */\n\n  VaultType[\"CustomPasscode\"] = \"CustomPasscode\";\n  /** Data will persist only while the application is in memory. */\n\n  VaultType[\"InMemory\"] = \"InMemory\";\n})(VaultType || (VaultType = {}));\n/**\n * For Android, when type is {@link VaultType.DeviceSecurity} and deviceSecurityType is {@link DeviceSecurityType.Both}, this options specifies if you want to\n * prefer a Strong Cryptographic Vault or the System Passcode fallback when they both aren't available.\n * @default `StrongVault`\n */\n\n\nvar AndroidBiometricCryptoPreference;\n\n(function (AndroidBiometricCryptoPreference) {\n  /** Prefer to use a strong cryptographic vault. */\n  AndroidBiometricCryptoPreference[\"StrongVault\"] = \"StrongVault\";\n  /** Prefer the system passcode fallback. */\n\n  AndroidBiometricCryptoPreference[\"SystemPasscode\"] = \"SystemPasscode\";\n})(AndroidBiometricCryptoPreference || (AndroidBiometricCryptoPreference = {})); // OLD METHODS\n\n/**\n * The type of authentication the vault should be configured to allow.\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\n\n\nvar AuthMode;\n\n(function (AuthMode) {\n  /**\n   * Biometrics authentication should only be allowed\n   */\n  AuthMode[AuthMode[\"BiometricOnly\"] = 0] = \"BiometricOnly\";\n  /**\n   * Passcode authentication should only be allowed\n   */\n\n  AuthMode[AuthMode[\"PasscodeOnly\"] = 1] = \"PasscodeOnly\";\n  /**\n   * Both biometric and passcode authentication should be allowed\n   */\n\n  AuthMode[AuthMode[\"BiometricAndPasscode\"] = 2] = \"BiometricAndPasscode\";\n  /**\n   * Both biometric and passcode authentication should be disabled.\n   * With this setting all data in the vault will be cleared on lock or\n   * if the app is closed. Stored data is kept only in memory.\n   */\n\n  AuthMode[AuthMode[\"InMemoryOnly\"] = 3] = \"InMemoryOnly\";\n  /**\n   * Use biometrics if it is available, otherwise use passcode\n   */\n\n  AuthMode[AuthMode[\"BiometricOrPasscode\"] = 4] = \"BiometricOrPasscode\";\n  /**\n   * Both biometric and passcode authentication will be disabled but any stored values\n   * will persist and be stored securely at rest using the keychain and will be available\n   * without needing to authenticate via passcode or biometrics when the device is unlocked.\n   */\n\n  AuthMode[AuthMode[\"SecureStorage\"] = 5] = \"SecureStorage\";\n})(AuthMode || (AuthMode = {}));\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst STORAGE_KEYS = {\n  DATA: \"data\"\n};\n/**\n * THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER. It only exists\n * as a way to run browser-compatible code in place of Identity Vault. Browsers\n * do not have a secure storage element same as native devices. This class\n * is intended to be used to enable running your application in the browser while\n * simulating the functions of Identity Vault using sessionStorage.\n *\n * Represents a vault implementation for browser compatibility.\n */\n\nclass BrowserVault {\n  /**\n   * @usage\n   * ```typescript\n   * const vault = new Vault({\n   *  key: 'com.company.myvaultapp',\n   *  type: 'CustomPasscode',\n   *  deviceSecurityType: 'Both',\n   *  lockAfterBackgrounded: 2000,\n   * });\n   * ```\n   * @param config\n   */\n  constructor(config) {\n    /** @ignore */\n    this.isVaultLocked = false;\n    console.warn(\"THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER AND IS NOT INTENDED FOR PRODUCTION USE. It only exists as a way to run browser-compatible code in place of Identity Vault. Browsers do not have a secure storage element same as native devices. This class is intended to be used to enable running your application in the browser while simulating the functions of Identity Vault using sessionStorage.\");\n    this.config = Object.assign({\n      deviceSecurityType: \"Both\",\n      androidBiometricsPreferStrongVaultOrSystemPasscode: \"StrongVault\",\n      shouldClearVaultAfterTooManyFailedAttempts: false,\n      customPasscodeInvalidUnlockAttempts: 5,\n      unlockVaultOnLoad: false\n    }, config);\n    this.isVaultLocked = config.unlockVaultOnLoad ? false : true;\n  }\n  /** See {@link Vault.doesVaultExist} */\n\n\n  doesVaultExist() {\n    const data = this.getDataObj();\n    return Promise.resolve(!!data);\n  }\n  /** See {@link Vault.clear} */\n\n\n  clear() {\n    this.unlockIfLocked();\n    sessionStorage.removeItem(this.getKey(STORAGE_KEYS.DATA));\n    return Promise.resolve();\n  }\n  /** See {@link Vault.exportVault} */\n\n\n  exportVault() {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    return Promise.resolve(data !== null && data !== void 0 ? data : {});\n  }\n  /** See {@link Vault.importVault} */\n\n\n  importVault(data) {\n    this.setDataObj(data);\n    return Promise.resolve();\n  }\n  /** See {@link Vault.isLocked} */\n\n\n  isLocked() {\n    return Promise.resolve(this.isVaultLocked);\n  }\n  /** See {@link Vault.getKeys} */\n\n\n  getKeys() {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    if (!data) return Promise.resolve([]);\n    return Promise.resolve(Object.keys(data));\n  }\n  /** See {@link Vault.getValue} */\n\n\n  getValue(key) {\n    var _a;\n\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    return Promise.resolve((_a = data === null || data === void 0 ? void 0 : data[key]) !== null && _a !== void 0 ? _a : null);\n  }\n  /** See {@link Vault.lock} */\n\n\n  lock() {\n    var _a;\n\n    (_a = this.lockCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    return Promise.resolve();\n  }\n  /** See {@link Vault.removeValue} */\n\n\n  removeValue(key) {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    if (!data) return Promise.resolve();\n    const _a = data,\n          _b = key;\n    _a[_b];\n\n    const dataAfterRemoval = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n    this.setDataObj(dataAfterRemoval);\n    return Promise.resolve();\n  }\n  /** See {@link Vault.setCustomPasscode} */\n\n\n  setCustomPasscode(passcode) {\n    return Promise.resolve();\n  }\n  /** See {@link Vault.setValue} */\n\n\n  setValue(key, value) {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n\n    if (!data) {\n      this.setDataObj({\n        [key]: value\n      });\n    } else {\n      this.setDataObj(Object.assign(Object.assign({}, data), {\n        [key]: value\n      }));\n    }\n\n    return Promise.resolve();\n  }\n  /** See {@link Vault.onConfigChanged} */\n\n\n  onConfigChanged(callback) {\n    this.configCallback = callback;\n  }\n  /** See {@link Vault.onError} */\n\n\n  onError(callback) {\n    this.errorCallback = callback;\n  }\n  /** See {@link Vault.onLock} */\n\n\n  onLock(callback) {\n    this.lockCallback = callback;\n  }\n  /** See {@link Vault.onPasscodeRequested} */\n\n\n  onPasscodeRequested(callback) {// No passcode support\n  }\n  /** See {@link Vault.onUnlock} */\n\n\n  onUnlock(callback) {\n    this.unlockCallback = callback;\n  }\n  /** See {@link Vault.unlock} */\n\n\n  unlock() {\n    var _a;\n\n    (_a = this.unlockCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    return Promise.resolve();\n  }\n  /** See {@link Vault.updateConfig} */\n\n\n  updateConfig(config) {\n    var _a;\n\n    this.config = config;\n    (_a = this.configCallback) === null || _a === void 0 ? void 0 : _a.call(this, config);\n    return Promise.resolve();\n  }\n  /** @ignore */\n\n\n  requestBiometricPrompt() {\n    this.unlockIfLocked();\n    return Promise.resolve(true);\n  }\n  /** @ignore */\n\n\n  unlockIfLocked() {\n    if (this.isVaultLocked) {\n      this.unlock();\n    }\n  }\n  /** @ignore */\n\n\n  getDataObj() {\n    var _a;\n\n    const value = sessionStorage.getItem(this.getKey(STORAGE_KEYS.DATA));\n    if (!value) return null;\n\n    try {\n      return JSON.parse(value);\n    } catch (e) {\n      (_a = this.errorCallback) === null || _a === void 0 ? void 0 : _a.call(this, {\n        message: \"Unable to parse data store\",\n        code: VaultErrorCodes.Unknown\n      });\n      return null;\n    }\n  }\n  /** @ignore */\n\n\n  setDataObj(data) {\n    var _a;\n\n    try {\n      const dataStr = JSON.stringify(data);\n      sessionStorage.setItem(this.getKey(STORAGE_KEYS.DATA), dataStr);\n    } catch (e) {\n      (_a = this.errorCallback) === null || _a === void 0 ? void 0 : _a.call(this, {\n        message: \"Unable to serialize data\",\n        code: VaultErrorCodes.Unknown\n      });\n    }\n  }\n  /** @ignore */\n\n\n  getKey(key) {\n    return `IV-${this.config.key}-${key}`;\n  }\n\n}\n/**\n * Represents a vault for secure value storage\n */\n\n\nclass Vault {\n  /**\n   * @usage\n   * ```typescript\n   * const vault = new Vault({\n   *  key: 'com.company.myvaultapp',\n   *  type: 'CustomPasscode',\n   *  deviceSecurityType: DeviceSecurityType.None,\n   *  lockAfterBackgrounded: 2000,\n   * });\n   * ```\n   * @param config\n   */\n  constructor(config) {\n    /** @ignore */\n    this.defaultConfig = {\n      deviceSecurityType: DeviceSecurityType.None,\n      androidBiometricsPreferStrongVaultOrSystemPasscode: AndroidBiometricCryptoPreference.StrongVault,\n      shouldClearVaultAfterTooManyFailedAttempts: false,\n      customPasscodeInvalidUnlockAttempts: 5,\n      unlockVaultOnLoad: false\n    }; // set defaults\n\n    this.config = Object.assign(this.defaultConfig, config); // setting sane defaults\n\n    if (config.deviceSecurityType === DeviceSecurityType.None && config.type === VaultType.DeviceSecurity) {\n      config.deviceSecurityType = DeviceSecurityType.Both;\n    }\n\n    this.resume = this.resume.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.setup().then(() => {\n      this.getPersistedVaultConfig();\n    });\n  }\n  /**\n   * Resolves true if a vault with the same key already exists, and false if not.\n   * The vault does not need to be unlocked to check.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const vaultExists = await vault.doesVaultExists()\n   * if (!vaultExists) {\n   *  // the vault does not exist...\n   * }\n   * ```\n   */\n\n\n  doesVaultExist() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        this.handleError(resolve, reject, error, () => this.doesVaultExist());\n      }, \"VaultPlugin\", \"doesVaultExist\", [this.config]);\n    });\n  }\n  /**\n   * Clears out the current vault and removes it from the system.\n   * Note: The vault does not need to be unlocked in order to clear it. No credentials are checked\n   * when clearing the vault.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.clear();\n   * ```\n   */\n\n\n  clear() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        resolve();\n      }, error => {\n        this.handleError(resolve, reject, error, () => this.clear());\n      }, \"VaultPlugin\", \"clear\", [this.config]);\n    });\n  }\n  /**\n   * Exports the data of the current vault in its entirety.\n   * The data is a map with keys that are strings and values that are JSON.\n   * Calling `exportVault` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const data = await vault.exportVault();\n   * ```\n   *\n   * @return The resolved object is a map with string keys and string values.\n   *\n   */\n\n\n  exportVault() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        this.handleError(resolve, reject, error, () => this.exportVault());\n      }, \"VaultPlugin\", \"exportVault\", [this.config]);\n    });\n  }\n  /**\n   * Imports data into the vault, replacing the current contents of the vault.\n   * The data is a map with keys that are strings and values that are JSON.\n   * Calling `importVault` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const dataFromElsewhere = await getUserData();\n   * const newVault = new Vault(vaultConfig);\n   * await newVault.importVault(dataFromElsewhere);\n   * ```\n   *\n   * @param data The entire data object to be imported. The shape of data must be {[key: string]: string}.\n   *\n   */\n\n\n  importVault(data) {\n    const jsonData = JSON.stringify(data);\n    return new Promise((resolve, reject) => {\n      cordova.exec(resolve, error => {\n        this.handleError(resolve, reject, error, () => this.importVault(data));\n      }, \"VaultPlugin\", \"importVault\", [this.config, jsonData]);\n    });\n  }\n  /**\n   * Checks if the vault is currently in a locked state, which signifies that the contents\n   * of the secure vault are not currently accessible. `isLocked` can also return true if the\n   * vault does not exist.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const locked = await vault.isLocked();\n   * if (locked) {\n   *  // vault is locked (or does not exist);\n   * }\n   * ```\n   */\n\n\n  isLocked() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        this.handleError(resolve, reject, error);\n      }, \"VaultPlugin\", \"isLocked\", [this.config]);\n    });\n  }\n  /**\n   * Returns an array of keys that are currently in the vault.\n   * Calling `getKeys` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const allKeys = await vault.getKeys();\n   * allKeys.forEach((key) => {\n   *  // do something with the key\n   * });\n   * ```\n   */\n\n\n  getKeys() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        this.handleError(resolve, reject, error, () => this.getKeys());\n      }, \"VaultPlugin\", \"getKeys\", [this.config]);\n    });\n  }\n  /**\n   * Gets the value for a given key. Returns null if the key does not exist.\n   * Calling `getValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const userFirstName = await vault.getValue<string>(\"firstname\");\n   * ```\n   *\n   * @param key The key to look up the value for\n   *\n   */\n\n\n  getValue(key) {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        if (!data) {\n          // android returns null as an empty string, so manually convert it here\n          resolve(null);\n        } else {\n          try {\n            resolve(JSON.parse(data));\n          } catch (err) {\n            resolve(data);\n          }\n        }\n      }, error => {\n        this.handleError(resolve, reject, error, () => this.getValue(key));\n      }, \"VaultPlugin\", \"getValue\", [this.config, key]);\n    });\n  }\n  /**\n   * Locks the vault if it is currently unlocked.\n   * Locking the vault with remove all secure data from memory inside of Identity Vault, but not your application.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.lock();\n   * ```\n   */\n\n\n  lock() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        resolve();\n      }, error => {\n        this.handleError(resolve, reject, error);\n      }, \"VaultPlugin\", \"lock\", [this.config]);\n    });\n  }\n  /**\n   * Removes a value from the vault.\n   * Calling `removeValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.removeValue(\"address\");\n   * ```\n   *\n   * @param key The key to remove\n   *\n   */\n\n\n  removeValue(key) {\n    return new Promise((resolve, reject) => {\n      cordova.exec(resolve, error => {\n        this.handleError(resolve, reject, error, () => this.removeValue(key));\n      }, \"VaultPlugin\", \"removeValue\", [this.config, key]);\n    });\n  }\n  /**\n   * When the vault type is set to 'CustomPasscode', this method sets the passcode required to\n   * secure the vault.\n   * This method is typically called in the `onPasscodeRequested` callback.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const code = window.prompt(\"Enter your passcode.\");\n   * if (code) {\n   *  await vault.setCustomPasscode(code);\n   * }\n   * ```\n   *\n   * @param passcode The user supplied passcode to secure the vault with.\n   *\n   */\n\n\n  setCustomPasscode(passcode) {\n    return new Promise((resolve, reject) => {\n      cordova.exec(resolve, error => {\n        this.handleError(resolve, reject, error);\n      }, \"VaultPlugin\", \"setCustomPasscode\", [this.config, passcode]);\n    });\n  }\n  /**\n   * Sets the value of an item in the vault.\n   * Calling `setValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.setValue<string>(\"theme\", theme);\n   * ```\n   *\n   * @param key The key for the new value.\n   * @param value The value to store in the vault. Value can be of any type, as it will be parsed to JSON in the vault.\n   *\n   */\n\n\n  setValue(key, value) {\n    const jsonValue = JSON.stringify(value);\n    return new Promise((resolve, reject) => {\n      cordova.exec(resolve, error => {\n        this.handleError(resolve, reject, error, () => this.setValue(key, value));\n      }, \"VaultPlugin\", \"setValue\", [this.config, key, jsonValue]);\n    });\n  }\n  /**\n   * Triggers when a config change occurs.\n   *\n   * @usage\n   * ```typescript\n   * vault.onConfigChanged((config) => {\n   *  console.log(\"updated config: \", config);\n   * });\n   * ```\n   * @param callback The callback function that will be called when the event triggers. Passes in the current vault config.\n   *\n   */\n\n\n  onConfigChanged(callback) {\n    cordova.exec(data => {\n      callback(JSON.parse(data));\n    }, error => console.error(error), \"VaultPlugin\", \"onConfigChanged\", []);\n  }\n  /**\n   * Triggers when an error occurs in the application.\n   * Errors that come back as rejected promises also trigger this event.\n   *\n   * @usage\n   * ```typescript\n   * vault.onError((err) => {\n   *  console.log('ERROR from callback', JSON.stringify(err));\n   * });\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers. Passes in the error object.\n   *\n   */\n\n\n  onError(callback) {\n    cordova.exec(() => {}, callback, \"VaultPlugin\", \"onError\", []);\n  }\n  /**\n   * Triggers when the vault enters a locked state.\n   *\n   * @usage\n   * ```typescript\n   * vault.onLock(() => { displayNotification(\"Vault locked.\"); })\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers.\n   *\n   */\n\n\n  onLock(callback) {\n    cordova.exec(callback, error => console.error(error), \"VaultPlugin\", \"onLock\", [this.config]);\n  }\n  /**\n   * For CustomPasscode vaults, this event triggers when the vault is attempting to unlock\n   * and the passcode has not been set yet. The callback function will pass in a Promise that,\n   * when resolved, with attempt to unlock the vault again calling the same method that originally\n   * tried to unlock the vault. Before the promise is resolved, you should prompt the user to supply a passcode, and\n   * then supply that value to `setCustomPasscode`.\n   *\n   * @usage\n   * ```typescript\n   * vault.onPasscodeRequested(async (isPasscodeSetRequest) => {\n   *  const message = isPasscodeSetRequest\n   *    ? 'Setup Passcode' // passcode is being set for first time\n   *    : 'Enter passcode'; // passcode is being asked for unlock\n   *  const passcode = window.prompt(message) || '';\n   *   vault.setCustomPasscode(passcode);\n   *   return Promise.resolve();\n   * });\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.\n   *\n   */\n\n\n  onPasscodeRequested(callback) {\n    this.passCodeRequestedCallback = callback;\n  }\n  /**\n   * Triggers when the vault enters an unlocked state.\n   *\n   * @usage\n   * ```typescript\n   * vault.onUnlock(() => {\n   *  console.log(\"vault is now unlocked\");\n   * });\n   * ```\n   * @param callback The callback function that will be called when the event triggers.\n   *\n   */\n\n\n  onUnlock(callback) {\n    cordova.exec(callback, error => console.error(error), \"VaultPlugin\", \"onUnlock\", [this.config]);\n  }\n  /**\n   * Manually unlock the vault. Will trigger any authentication mechanism needed to access the vault (passcode, biometrics, etc..).\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.unlock();\n   * ```\n   */\n\n\n  unlock() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(() => {\n        resolve();\n      }, error => {\n        this.handleError(resolve, reject, error, () => this.unlock());\n      }, \"VaultPlugin\", \"unlock\", [this.config]);\n    });\n  }\n  /**\n   * Updates the configuration of the current vault.\n   *\n   *  @usage\n   * ```typescript\n   * async function changeVaultType(type: VaultType) {\n   *  const vault = new Vault(this.existingVaultConfig);\n   *  const newConfig = { ...this.existingVaultConfig, type };\n   *  await vault.updateConfig(newConfig);\n   *  this.existingVaultConfig = newConfig;\n   * }\n   * ```\n   *\n   * @param config The new config\n   *\n   */\n\n\n  updateConfig(config) {\n    return new Promise((resolve, reject) => {\n      config = Object.assign(this.defaultConfig, config); // setting sane defaults\n\n      if (config.deviceSecurityType === DeviceSecurityType.None && config.type === VaultType.DeviceSecurity) {\n        config.deviceSecurityType = DeviceSecurityType.Both;\n      }\n\n      cordova.exec(() => {\n        this.config = config;\n        resolve();\n      }, error => {\n        this.handleError(resolve, reject, error, () => this.updateConfig(config));\n      }, \"VaultPlugin\", \"updateConfig\", [config]);\n    });\n  }\n  /** @ignore */\n\n\n  handleError(resolve, reject, error, retryFunc) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (error.code === VaultErrorCodes.MissingPasscode && _this.passCodeRequestedCallback) {\n        yield _this.passCodeRequestedCallback(error.extra.isPasscodeSetRequest);\n\n        if (retryFunc) {\n          try {\n            const data = yield retryFunc();\n            resolve(data);\n          } catch (e) {\n            reject(e);\n          }\n        }\n      } else if (error.code === VaultErrorCodes.MissingBiometrics) {\n        cordova.exec( /*#__PURE__*/_asyncToGenerator(function* () {\n          const data = yield retryFunc();\n          resolve(data);\n        }), e => reject(e), \"VaultPlugin\", \"requestBiometricPrompt\", [_this.config]);\n      } else {\n        reject(error);\n      }\n    })();\n  }\n  /** @ignore */\n\n\n  requestBiometricPrompt() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        this.handleError(resolve, reject, error, () => this.requestBiometricPrompt());\n      }, \"VaultPlugin\", \"requestBiometricPrompt\", [this.config]);\n    });\n  }\n  /**\n   * @ignore\n   */\n\n\n  resume() {\n    const noop = () => {};\n\n    cordova.exec(noop, error => {\n      this.handleError(noop, noop, error, () => this.resume());\n    }, \"VaultPlugin\", \"appResumed\", [this.config]);\n  }\n  /**\n   * @ignore\n   */\n\n\n  setup() {\n    return new Promise((resolve, reject) => {\n      document.addEventListener(\"resume\", this.resume, false);\n      cordova.exec(resolve, error => {\n        this.handleError(resolve, reject, error);\n      }, \"VaultPlugin\", \"setup\", [this.config]);\n    });\n  }\n  /**\n   * @ignore\n   */\n\n\n  getPersistedVaultConfig() {\n    return new Promise((resolve, reject) => {\n      cordova.exec(data => {\n        if (!data) {\n          resolve();\n        } else {\n          const vaultConfig = JSON.parse(data);\n          this.config = Object.assign(this.config, vaultConfig);\n          resolve();\n        }\n      }, error => {\n        this.handleError(resolve, reject, error);\n      }, \"VaultPlugin\", \"getVaultConfig\", [this.config]);\n    });\n  }\n\n}\n\nclass Device {\n  /** @ignore */\n  constructor() {}\n  /**\n   * Gets the types of biometrics the device supports.\n   *\n   * @usage\n   * ```typescript\n   * const hardware = await Device.getAvailableHardware();\n   * hardware.forEach((biometricType) => console.log(\"Type: \" + biometricType));\n   * ```\n   */\n\n\n  static getAvailableHardware() {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve([]);\n        return;\n      }\n\n      cordova.exec(data => {\n        resolve(data);\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"getAvailableHardware\", []);\n    });\n  }\n  /**\n   * Check whether biometrics are locked out on the device.\n   *\n   * On Android, the locked out state will only known after an attempted biometric unlock.\n   *\n   * @usage\n   * ```typescript\n   * const isLockedOut = await Device.isLockedOutOfBiometrics();\n   * if (isLockedOut) {\n   *  // device is locked out ...\n   * }\n   * ```\n   */\n\n\n  static isLockedOutOfBiometrics() {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"isLockedOutOfBiometrics\", []);\n    });\n  }\n  /**\n   * Checks the device biometric strength level.\n   *\n   * On iOS this will always return 'strong'.\n   *\n   * @usage\n   * ```typescript\n   * const biometricStrength = await Device.getBiometricStrengthLevel();\n   * ```\n   */\n\n\n  static getBiometricStrengthLevel() {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(BiometricSecurityStrength.Weak);\n        return;\n      }\n\n      cordova.exec(data => {\n        resolve(data);\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"getBiometricStrengthLevel\", []);\n    });\n  }\n  /**\n   * Check whether or not the screen will be obscured in app switcher mode.\n   *\n   * @usage\n   * ```typescript\n   * const willHideScreen = await Device.isHideScreenOnBackgroundEnabled();\n   * ```\n   */\n\n\n  static isHideScreenOnBackgroundEnabled() {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"isHideScreenOnBackgroundEnabled\", []);\n    });\n  }\n  /**\n   * Set whether or not the screen will be obscured in app switcher mode\n   *\n   * @usage\n   * ```typescript\n   * await Device.setHideScreenOnBackground(true);\n   * ```\n   */\n\n\n  static setHideScreenOnBackground(enabled) {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve();\n        return;\n      }\n\n      cordova.exec(() => {\n        resolve();\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"setHideScreenOnBackground\", [enabled]);\n    });\n  }\n  /**\n   * Check whether the device OS-level passcode has been set.\n   *\n   * @usage\n   * ```typescript\n   * const hasSystemPasscode = await Device.isSystemPasscodeSet();\n   * if (hasSystemPasscode) {\n   *  // device has a system passcode\n   * }\n   * ```\n   */\n\n\n  static isSystemPasscodeSet() {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"isSystemPasscodeSet\", []);\n    });\n  }\n  /**\n   * Check whether or not biometrics is supported by the device and has been configured by the current user of the device.\n   *\n   * @usage\n   * ```typescript\n   * const biometricsEnabled = await Device.isBiometricsEnabled();\n   * if (!biometricsEnabled) {\n   *  // biometrics not enabled on this device...\n   * }\n   * ```\n   */\n\n\n  static isBiometricsEnabled() {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(data => {\n        console.log(\"biometrics is enabled: \", data);\n        resolve(JSON.parse(data));\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"isBiometricsEnabled\", []);\n    });\n  }\n  /**\n   * Check whether or not biometrics is supported by the device.\n   *\n   * @usage\n   * ```typescript\n   * const biometricsSupported = await Device.isBiometricsSupported();\n   * if (biometricsSupported) {\n   *   // biometrics is supported on this device...\n   * }\n   * ```\n   */\n\n\n  static isBiometricsSupported() {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"isBiometricsSupported\", []);\n    });\n  }\n  /**\n   * Check if the device has a secure hardware enclave.\n   *\n   * @usage\n   * ```typescript\n   * const hasSecureHardware = await Device.hasSecureHardware();\n   * if (!hasSecureHardware) {\n   *    // this device doesn't have secure hardware\n   * }\n   * ```\n   */\n\n\n  static hasSecureHardware() {\n    return new Promise((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(data => {\n        resolve(JSON.parse(data));\n      }, error => {\n        Device.handleError(resolve, reject, error);\n      }, \"DevicePlugin\", \"hasSecureHardware\", []);\n    });\n  }\n  /**\n   * @ignore\n   */\n\n\n  static handleError(resolve, reject, error, retryFunc) {\n    return _asyncToGenerator(function* () {\n      reject(error);\n    })();\n  }\n\n}\n/**\n * @hidden\n *\n * @ignore\n */\n\n\nclass IonicIdentityVaultUser {\n  constructor(platform, options, descriptor) {\n    this.platform = platform;\n    this.options = options;\n    this._readyCalled = false;\n    this.descriptor = descriptor || {\n      username: '_lastUser',\n      vaultId: 'default'\n    };\n    this._readyPromise = this.initializeVault();\n  }\n\n  get token() {\n    const session = this.session;\n    return session && session.token;\n  }\n\n  get username() {\n    const session = this.session;\n    return session && session.username;\n  }\n\n  get config() {\n    if (!this._config) {\n      return undefined;\n    }\n\n    let authMode;\n    const bioEnabled = this._config.isBiometricsEnabled;\n    const passEnabled = this._config.isPasscodeEnabled;\n    const secureStorageMode = this._config.isSecureStorageModeEnabled;\n\n    if (secureStorageMode) {\n      authMode = AuthMode.SecureStorage;\n    } else if (bioEnabled && passEnabled) {\n      authMode = AuthMode.BiometricAndPasscode;\n    } else if (bioEnabled && !passEnabled) {\n      authMode = AuthMode.BiometricOnly;\n    } else if (!bioEnabled && passEnabled) {\n      authMode = AuthMode.PasscodeOnly;\n    } else if (!bioEnabled && !passEnabled) {\n      authMode = AuthMode.InMemoryOnly;\n    }\n\n    return {\n      authMode: authMode,\n      isPasscodeSetupNeeded: this._config.isPasscodeSetupNeeded,\n      lockAfter: this._config.lockAfter,\n      hideScreenOnBackground: this._config.hideScreenOnBackground\n    };\n  } // overidable event handlers\n\n\n  onVaultLocked(_event) {}\n\n  onSessionRestoreError(_err) {}\n\n  onUnlockOnReadyError(_err) {}\n\n  onVaultUnlocked(_config) {}\n\n  onVaultReady(_config) {}\n\n  onSetupError(_error) {}\n\n  onConfigChange(_config) {}\n\n  onSessionRestored(_session) {}\n\n  onPasscodeRequest(_isPasscodeSetRequest) {\n    return _asyncToGenerator(function* () {\n      return;\n    })();\n  }\n\n  onReady(vault) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2._readyCalled) {\n        return;\n      }\n\n      _this2._readyCalled = true;\n      _this2.vault = vault;\n      const inUse = yield _this2.vault.isInUse();\n      _this2._config = vault.config;\n      const locked = yield _this2.vault.isLocked();\n      let restoreSessionError;\n\n      try {\n        if (_this2.options.restoreSessionOnReady && inUse) {\n          yield _this2._restoreSession();\n        }\n      } catch (e) {\n        restoreSessionError = e;\n      }\n\n      let unlockOnReadyError;\n\n      try {\n        if (locked && _this2.options.unlockOnReady) {\n          yield _this2._unlock();\n        }\n      } catch (e) {\n        unlockOnReadyError = e;\n      } // Note Swallow all errors in init like Vault is Locked Etc.\n\n\n      try {\n        if (!inUse) {\n          yield _this2._trySetAuthMode(_this2.options.authMode);\n        }\n      } catch (e) {}\n\n      _this2._readyResolve();\n\n      _this2.onVaultReady(_this2.config);\n\n      if (restoreSessionError) {\n        _this2.onSessionRestoreError(restoreSessionError);\n      }\n\n      if (unlockOnReadyError) {\n        _this2.onUnlockOnReadyError(restoreSessionError);\n      }\n    })();\n  }\n\n  onLock(event) {\n    this.session = undefined;\n    this.onVaultLocked(event);\n  }\n\n  onUnlock(config) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.ready();\n      _this3._config = config;\n\n      _this3.onVaultUnlocked(_this3.config);\n    })();\n  }\n\n  onError(error) {\n    this._readyReject(error);\n\n    this.onSetupError(error);\n  }\n\n  onConfig(config) {\n    this._config = config;\n    this.onConfigChange(this.config);\n  }\n\n  ready() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this4._readyPromise;\n    })();\n  }\n\n  _unlock(authMode) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const locked = yield _this5.vault.isLocked();\n\n      if (!locked) {\n        return;\n      }\n\n      authMode = authMode !== undefined && authMode !== AuthMode.BiometricOrPasscode ? authMode : _this5.config.authMode;\n\n      switch (authMode) {\n        case AuthMode.BiometricOnly:\n          return _this5.vault.unlock();\n\n        case AuthMode.PasscodeOnly:\n          return _this5.unlockWithPasscode();\n\n        case AuthMode.BiometricAndPasscode:\n          try {\n            yield _this5.vault.unlock();\n            return;\n          } catch (e) {\n            const handleableErrors = [VaultErrorCodes.AuthFailed, VaultErrorCodes.BiometricsNotEnabled, VaultErrorCodes.UserCanceledInteraction, VaultErrorCodes.InvalidatedCredential];\n\n            if (handleableErrors.indexOf(e.code) > -1) {\n              yield _this5.unlockWithPasscode(); // The user removed fingerprints/faceID and so the bio creds are gone\n              // if they are using passcode auth we can resave the credential to autoreset\n              // the mode to PasscodeOnly if bio is no longer available.\n\n              if (e.code === VaultErrorCodes.InvalidatedCredential) {\n                const session = yield _this5.restoreSession();\n                yield _this5.saveSession(session);\n              }\n\n              return;\n            }\n\n            throw e;\n          }\n\n      }\n    })();\n  }\n\n  unlock(authMode) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6.ready();\n      return _this6._unlock(authMode);\n    })();\n  }\n\n  unlockWithPasscode() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const passcode = yield _this7.onPasscodeRequest(false);\n      return _this7.vault.unlock(true, passcode);\n    })();\n  }\n\n  _setPasscode() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const locked = yield _this8.vault.isLocked();\n\n      if (locked) {\n        throw {\n          code: VaultErrorCodes.VaultLocked,\n          message: \"Operation not allowed while vault locked.\"\n        };\n      }\n\n      const passcode = yield _this8.onPasscodeRequest(true);\n      return _this8.vault.setPasscode(passcode);\n    })();\n  }\n\n  setPasscode() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this9.ready();\n      return _this9._setPasscode();\n    })();\n  }\n\n  getSession() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this10.ready();\n\n      if (_this10.options.unlockOnAccess) {\n        yield _this10._unlock();\n      }\n\n      return _this10.session;\n    })();\n  }\n\n  _restoreSession() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const inUse = yield _this11.vault.isInUse();\n\n      if (!inUse) {\n        return;\n      }\n\n      if (_this11.options.unlockOnAccess) {\n        yield _this11._unlock();\n      }\n\n      _this11.session = yield _this11.vault.getValue('session');\n\n      _this11.onSessionRestored(_this11.session);\n\n      return _this11.session;\n    })();\n  }\n\n  restoreSession() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this12.ready();\n      return _this12._restoreSession();\n    })();\n  }\n\n  saveSession(session) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this13.ready();\n\n      if (_this13.config.isPasscodeSetupNeeded) {\n        yield _this13.setPasscode();\n      }\n\n      try {\n        yield _this13.vault.storeValue('session', session);\n      } catch (e) {\n        // Catch the case where Biometrics with Passcode Fallback\n        // was enabled but the user disabled passcode or removed their\n        // fingerprints/faceid and try to recover by setting to passcode only\n        // mode.\n        if (e.code === VaultErrorCodes.SecurityNotAvailable) {\n          const authMode = yield _this13.getAuthMode();\n\n          if (authMode === AuthMode.BiometricAndPasscode) {\n            yield _this13.setAuthMode(AuthMode.PasscodeOnly);\n            return _this13.saveSession(session);\n          }\n        }\n\n        throw e;\n      }\n\n      _this13.session = session;\n    })();\n  }\n\n  login(session, authMode) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this14.ready();\n      yield _this14.logout();\n      yield _this14._trySetAuthMode(authMode);\n      return _this14.saveSession(session);\n    })();\n  }\n\n  getVault() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this15.ready();\n      return _this15.vault;\n    })();\n  }\n\n  initializeVault() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this16.platform.ready();\n\n      if (_this16.vault != null) {\n        return Promise.resolve();\n      }\n\n      if (_this16.vIonicNativeAuth == null) {\n        _this16.vIonicNativeAuth = _this16.getPlugin();\n      }\n\n      const readyPromise = new Promise((resolve, reject) => {\n        _this16._readyResolve = resolve;\n        _this16._readyReject = reject;\n      });\n      const {\n        lockAfter,\n        hideScreenOnBackground,\n        shouldClearVaultAfterTooManyFailedAttempts,\n        allowSystemPinFallback,\n        androidPromptNegativeButtonText,\n        androidPromptTitle,\n        androidPromptSubtitle,\n        androidPromptDescription,\n        iosPromptText\n      } = _this16.options;\n      _this16.vault = _this16.vIonicNativeAuth.getVault(Object.assign(Object.assign({\n        lockAfter,\n        hideScreenOnBackground,\n        shouldClearVaultAfterTooManyFailedAttempts,\n        allowSystemPinFallback,\n        androidPromptNegativeButtonText,\n        androidPromptTitle,\n        androidPromptSubtitle,\n        androidPromptDescription,\n        iosPromptText\n      }, _this16.descriptor), {\n        onLock: _this16.onLock.bind(_this16),\n        onConfig: _this16.onConfig.bind(_this16),\n        onError: _this16.onError.bind(_this16),\n        onUnlock: _this16.onUnlock.bind(_this16),\n        onReady: _this16.onReady.bind(_this16)\n      }));\n      return readyPromise;\n    })();\n  }\n\n  getPlugin() {\n    return IonicNativeAuth;\n  }\n\n  getBiometricType() {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this17.ready();\n      return _this17.vault.getBiometricType();\n    })();\n  }\n\n  getAvailableHardware() {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this18.ready();\n      return _this18.vault.getAvailableHardware();\n    })();\n  }\n\n  lockOut() {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this19.ready();\n      yield _this19.vault.lock();\n      _this19.session = undefined;\n    })();\n  }\n\n  logout() {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this20.ready();\n      yield _this20.vault.clear();\n      _this20.session = undefined;\n      _this20._config = yield _this20.vault.getConfig();\n    })();\n  }\n\n  hasStoredSession() {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this21.ready();\n      return _this21.vault.isInUse();\n    })();\n  }\n\n  setBiometricsEnabled(isBiometricsEnabled) {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this22.ready();\n      return _this22._setBiometricsEnabled(isBiometricsEnabled);\n    })();\n  }\n\n  _setBiometricsEnabled(isBiometricsEnabled) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this23.vault.setBiometricsEnabled(isBiometricsEnabled);\n    })();\n  }\n\n  setHideScreenOnBackground(enabled) {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this24.ready();\n      return _this24.vault.setHideScreenOnBackground(enabled);\n    })();\n  }\n\n  setPasscodeEnabled(isPasscodeEnabled) {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this25.ready();\n      yield _this25._setPasscodeEnabled(isPasscodeEnabled);\n    })();\n  }\n\n  _setPasscodeEnabled(isPasscodeEnabled) {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this26.vault.setPasscodeEnabled(isPasscodeEnabled);\n      _this26._config = yield _this26.vault.getConfig();\n\n      if (_this26.config.isPasscodeSetupNeeded) {\n        yield _this26._setPasscode();\n      }\n    })();\n  }\n\n  isBiometricsEnabled() {\n    var _this27 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this27.ready();\n      return _this27.vault.isBiometricsEnabled();\n    })();\n  }\n\n  isBiometricsAvailable() {\n    var _this28 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this28.ready();\n      return _this28.vault.isBiometricsAvailable();\n    })();\n  }\n\n  isBiometricsSupported() {\n    var _this29 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this29.ready();\n      return _this29.vault.isBiometricsSupported();\n    })();\n  }\n\n  isSecureStorageModeEnabled() {\n    var _this30 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this30.ready();\n      return _this30.vault.isSecureStorageModeEnabled();\n    })();\n  }\n\n  isPasscodeEnabled() {\n    var _this31 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this31.ready();\n      return _this31.vault.isPasscodeEnabled();\n    })();\n  }\n\n  _setAuthMode(authMode) {\n    var _this32 = this;\n\n    return _asyncToGenerator(function* () {\n      authMode = authMode !== undefined ? authMode : _this32.config.authMode;\n\n      if (authMode === _this32.config.authMode) {\n        return;\n      }\n\n      switch (authMode) {\n        case AuthMode.BiometricOnly:\n          yield _this32._setBiometricsEnabled(true);\n          yield _this32._setPasscodeEnabled(false);\n          break;\n\n        case AuthMode.PasscodeOnly:\n          yield _this32._setPasscodeEnabled(true);\n          yield _this32._setBiometricsEnabled(false);\n          break;\n\n        case AuthMode.BiometricAndPasscode:\n          yield _this32._setPasscodeEnabled(true);\n          yield _this32._setBiometricsEnabled(true);\n          break;\n\n        case AuthMode.BiometricOrPasscode:\n          try {\n            yield _this32._setBiometricsEnabled(true);\n            yield _this32._setPasscodeEnabled(false);\n          } catch (error) {\n            yield _this32._setPasscodeEnabled(true);\n          }\n\n          break;\n\n        case AuthMode.InMemoryOnly:\n          yield _this32._setPasscodeEnabled(false);\n          yield _this32._setBiometricsEnabled(false);\n          yield _this32.vault.setSecureStorageModeEnabled(false);\n          break;\n\n        case AuthMode.SecureStorage:\n          // Note: Setting this mode automatically disables the other modes in native code.\n          yield _this32.vault.setSecureStorageModeEnabled(true);\n          break;\n\n        default:\n          throw {\n            code: VaultErrorCodes.InvalidAuthMode,\n            message: \"Invalid AuthMode\"\n          };\n      }\n    })();\n  }\n\n  _trySetAuthMode(authMode) {\n    var _this33 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this33._setAuthMode(authMode);\n      } catch (error) {\n        if (error.code !== VaultErrorCodes.BiometricsNotEnabled && error.code !== VaultErrorCodes.SecurityNotAvailable) {\n          throw error;\n        }\n      }\n    })();\n  }\n\n  setAuthMode(authMode) {\n    var _this34 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this34.ready();\n      return _this34._setAuthMode(authMode);\n    })();\n  }\n\n  getAuthMode() {\n    var _this35 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this35.ready();\n      _this35._config = yield _this35.vault.getConfig();\n      return _this35.config.authMode;\n    })();\n  }\n\n}\n\nclass MigratorVault extends IonicIdentityVaultUser {\n  constructor(options, onPasscodeRequest, descriptor) {\n    super({\n      ready: () => Promise.resolve(true)\n    }, options, descriptor);\n\n    if (onPasscodeRequest) {\n      this.onPasscodeRequest = onPasscodeRequest;\n    }\n  }\n\n  static getInstance(options, onPasscodeRequest, descriptor) {\n    if (!MigratorVault.instance) {\n      MigratorVault.instance = new MigratorVault(options, onPasscodeRequest, descriptor);\n    }\n\n    return MigratorVault.instance;\n  }\n\n}\n\nMigratorVault.instance = undefined;\n\nclass VaultMigrator {\n  /**\n   *\n   * @usage\n   * ```typescript\n   * const legacyVaultConfig = {\n   *  unlockOnAccess: true,\n   *  hideScreenOnBackground: true,\n   *  lockAfter: 5000,\n   *  // and more ....\n   * }\n   * const migrator = new VaultMigrator(legacyVaultConfig, customPasscodePrompt);\n   * ```\n   * @param options The legacy vault configuration options\n   * @param onPasscodeRequest An optional callback function that will be called when the vault attempts to request a passcode. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.\n   * @param descriptor An optional interface that describes the legacy vault.\n   */\n  constructor(options, onPasscodeRequest, descriptor) {\n    this.migratorSession = MigratorVault.getInstance(options, onPasscodeRequest, descriptor);\n  }\n  /**\n   * Exports the data of the legacy vault in its entirety.\n   *\n   * @usage\n   * ```typescript\n   * const data = await migrator.exportVault();\n   * console.log(\"@@VAULT DATA: \", JSON.stringify(data));\n   * ```\n   * @returns\n   */\n\n\n  exportVault() {\n    var _this36 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(yield _this36.migratorSession.hasStoredSession())) {\n        throw Error(\"no data in legacy vault\");\n      }\n\n      yield _this36.migratorSession.unlock();\n      const vault = yield _this36.migratorSession.getVault();\n      const keys = yield vault.getKeys();\n      let vaultData = {};\n\n      for (let i = 0; i < keys.length; i++) {\n        const keyValue = yield vault.getValue(keys[i]);\n        vaultData[keys[i]] = keyValue;\n      }\n\n      return vaultData;\n    })();\n  }\n  /**\n   * Clears out the legacy vault and removes it from the system.  Be sure to run {@link VaultMigrator.exportVault} before calling this method.\n   *\n   * @usage\n   * ```typescript\n   * const data = await migrator.exportVault();\n   * await importVault(data);\n   * await migrator.clear();\n   * ```\n   */\n\n\n  clear() {\n    var _this37 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this37.migratorSession.getVault();\n      return vault.clear();\n    })();\n  }\n\n}\n\nexport { AndroidBiometricCryptoPreference, AuthMode, BiometricSecurityStrength, BrowserVault, Device, DeviceSecurityType, SupportedBiometricType, Vault, VaultErrorCodes, VaultMigrator, VaultType };","map":{"version":3,"sources":["/Users/i711243/Desktop/projects/Duplicate_Projects/Identity_vault/node_modules/@ionic-enterprise/identity-vault/dist/index.js"],"names":["VaultErrorCodes","SupportedBiometricType","BiometricSecurityStrength","DeviceSecurityType","VaultType","AndroidBiometricCryptoPreference","AuthMode","__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","STORAGE_KEYS","DATA","BrowserVault","constructor","config","isVaultLocked","console","warn","assign","deviceSecurityType","androidBiometricsPreferStrongVaultOrSystemPasscode","shouldClearVaultAfterTooManyFailedAttempts","customPasscodeInvalidUnlockAttempts","unlockVaultOnLoad","doesVaultExist","data","getDataObj","Promise","resolve","clear","unlockIfLocked","sessionStorage","removeItem","getKey","exportVault","importVault","setDataObj","isLocked","getKeys","keys","getValue","key","_a","lock","lockCallback","removeValue","_b","dataAfterRemoval","setCustomPasscode","passcode","setValue","value","onConfigChanged","callback","configCallback","onError","errorCallback","onLock","onPasscodeRequested","onUnlock","unlockCallback","unlock","updateConfig","requestBiometricPrompt","getItem","JSON","parse","message","code","Unknown","dataStr","stringify","setItem","Vault","defaultConfig","None","StrongVault","type","DeviceSecurity","Both","resume","bind","handleError","setup","then","getPersistedVaultConfig","reject","cordova","exec","error","jsonData","err","jsonValue","passCodeRequestedCallback","retryFunc","MissingPasscode","extra","isPasscodeSetRequest","MissingBiometrics","noop","document","addEventListener","vaultConfig","Device","getAvailableHardware","window","isLockedOutOfBiometrics","getBiometricStrengthLevel","Weak","isHideScreenOnBackgroundEnabled","setHideScreenOnBackground","enabled","isSystemPasscodeSet","isBiometricsEnabled","log","isBiometricsSupported","hasSecureHardware","IonicIdentityVaultUser","platform","options","descriptor","_readyCalled","username","vaultId","_readyPromise","initializeVault","token","session","_config","undefined","authMode","bioEnabled","passEnabled","isPasscodeEnabled","secureStorageMode","isSecureStorageModeEnabled","SecureStorage","BiometricAndPasscode","BiometricOnly","PasscodeOnly","InMemoryOnly","isPasscodeSetupNeeded","lockAfter","hideScreenOnBackground","onVaultLocked","_event","onSessionRestoreError","_err","onUnlockOnReadyError","onVaultUnlocked","onVaultReady","onSetupError","_error","onConfigChange","onSessionRestored","_session","onPasscodeRequest","_isPasscodeSetRequest","onReady","vault","inUse","isInUse","locked","restoreSessionError","restoreSessionOnReady","_restoreSession","unlockOnReadyError","unlockOnReady","_unlock","_trySetAuthMode","_readyResolve","event","ready","_readyReject","onConfig","BiometricOrPasscode","unlockWithPasscode","handleableErrors","AuthFailed","BiometricsNotEnabled","UserCanceledInteraction","InvalidatedCredential","restoreSession","saveSession","_setPasscode","VaultLocked","setPasscode","getSession","unlockOnAccess","storeValue","SecurityNotAvailable","getAuthMode","setAuthMode","login","logout","getVault","vIonicNativeAuth","getPlugin","readyPromise","allowSystemPinFallback","androidPromptNegativeButtonText","androidPromptTitle","androidPromptSubtitle","androidPromptDescription","iosPromptText","IonicNativeAuth","getBiometricType","lockOut","getConfig","hasStoredSession","setBiometricsEnabled","_setBiometricsEnabled","setPasscodeEnabled","_setPasscodeEnabled","isBiometricsAvailable","_setAuthMode","setSecureStorageModeEnabled","InvalidAuthMode","MigratorVault","getInstance","instance","VaultMigrator","migratorSession","Error","vaultData","keyValue"],"mappings":"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","sourcesContent":["/*! Ionic Enterprise Identity Vault: https://ionicframework.com/ - Commercially Licensed */\n/**\n * The meaning of the error code in the thrown {@link VaultError}.\n */\nvar VaultErrorCodes;\n(function (VaultErrorCodes) {\n    /**\n     * An unknown error happened.\n     * @constant `0`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * The operation failed because the vault was locked.\n     * @constant `1`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"VaultLocked\"] = 1] = \"VaultLocked\";\n    /**\n     * The operation failed because the vault was unavailable.\n     * The most likely cause of this error is that a vault has not been configured.\n     * @constant `2`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"VaultUnavailable\"] = 2] = \"VaultUnavailable\";\n    /**\n     * The operation failed because the some of the vault provided arguments were invalid.\n     * @constant `3`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"InvalidArguments\"] = 3] = \"InvalidArguments\";\n    /**\n     * The credentials were invalidated. This can happen when a user changes biometrics or passcode.\n     * @constant `4`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"InvalidatedCredential\"] = 4] = \"InvalidatedCredential\";\n    /**\n     * Biometric security is unavailable due to a passcode not being set up at the system level.\n     * In order to use biometric identification on the device a system level passcode must be set up by the user.\n     * @constant `5`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"SecurityNotAvailable\"] = 5] = \"SecurityNotAvailable\";\n    /**\n     * User authentication failed.\n     * @constant `6`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"AuthFailed\"] = 6] = \"AuthFailed\";\n    /**\n     * Too many failed authentication attempts made against the custom passcode vault, so the vault was cleared and user will need to login again.\n     * @constant `7`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"TooManyFailedAttempts\"] = 7] = \"TooManyFailedAttempts\";\n    /**\n     * The user cancelled the native authentication dialog.\n     *\n     * **Note**: On iOS, this error code will also be thrown in the event that the native authentication dialog fails as a result of too many failed attempts.\n     * The user will be forced to cancel the dialog, triggering this error code.\n     *\n     * On Android, this error also will be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both} in the event of too many failed attempts.\n     * Its currently not possible to get the nature of failures from the native authentication dialog, and similar to iOS, the user will be forced to cancel the dialog, triggering this error code.\n     * @constant `8`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"UserCanceledInteraction\"] = 8] = \"UserCanceledInteraction\";\n    /**\n     * The user provided mismatched passcodes.\n     * @constant `9`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"MismatchedPasscode\"] = 9] = \"MismatchedPasscode\";\n    /**\n     * The operation requires passcode to be setup but it isn't set yet. Call {@link Vault.setCustomPasscode} to set it.\n     * @constant `10`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"MissingPasscode\"] = 10] = \"MissingPasscode\";\n    /**\n     * The operation failed because the application tried to unlock the vault with passcode authentication,\n     * but the vault is not configured to allow passcode authentication.\n     * @constant `11`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"PasscodeNotEnabled\"] = 11] = \"PasscodeNotEnabled\";\n    /**\n     * The key was not found. This can happen when a user changes biometrics or passcode.\n     * @constant `12`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"KeyNotFound\"] = 12] = \"KeyNotFound\";\n    /**\n     * The operation failed because biometric authentication is not enabled.\n     * This can occur when biometrics is not supported by the device\n     * or when biometrics has not been configured for the device or vault.\n     * @constant `13`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"BiometricsNotEnabled\"] = 13] = \"BiometricsNotEnabled\";\n    /**\n     * @ignore\n     */\n    VaultErrorCodes[VaultErrorCodes[\"InvalidAuthMode\"] = 14] = \"InvalidAuthMode\";\n    /**\n     * Biometrics have not been authed yet (Android only)\n     * @constant `15`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"MissingBiometrics\"] = 15] = \"MissingBiometrics\";\n    /**\n     * {@link DeviceSecurityType.SystemPasscode} for {@link DeviceSecurityType} not available on this Android device.\n     * @constant `16`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"AndroidSystemPasscodeUnavailable\"] = 16] = \"AndroidSystemPasscodeUnavailable\";\n    /**\n     * Biometrics have been locked out, usually because of too many failed attempts.\n     *\n     * **Note:** This error will never be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both}.\n     * Its currently not possible to get the nature of failures from the native authentication dialog, so the only error that would be thrown is {@link VaultErrorCodes.UserCanceledInteraction} as the user\n     * is forced to cancel the prompt.\n     *\n     * @constant `17`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"AndroidBiometricsLockedOut\"] = 17] = \"AndroidBiometricsLockedOut\";\n    /**\n     * Biometrics have been locked out, usually because of too many failed attempts.\n     *\n     * @constant `18`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"iOSBiometricsLockedOut\"] = 18] = \"iOSBiometricsLockedOut\";\n    /**\n     * An unexpected error has occurred in the Android keystore.\n     *\n     * @constant `19`\n     */\n    VaultErrorCodes[VaultErrorCodes[\"AndroidUnexpectedKeystoreError\"] = 19] = \"AndroidUnexpectedKeystoreError\";\n})(VaultErrorCodes || (VaultErrorCodes = {}));\n/**\n * The possible values returned by {@link Device.getAvailableHardware}\n */\nvar SupportedBiometricType;\n(function (SupportedBiometricType) {\n    /** The device supports fingerprint scanning. */\n    SupportedBiometricType[\"Fingerprint\"] = \"fingerprint\";\n    /** The device supports facial recognition. */\n    SupportedBiometricType[\"Face\"] = \"face\";\n    /** The device supports iris scanning. */\n    SupportedBiometricType[\"Iris\"] = \"iris\";\n})(SupportedBiometricType || (SupportedBiometricType = {}));\n/**\n * Possible device biometric strength levels on Android (always `strong` on iOS).\n * [More Information](https://source.android.com/security/biometric/measure#tiered-authentication).\n */\nvar BiometricSecurityStrength;\n(function (BiometricSecurityStrength) {\n    /** Refers to Class 2 - Weak biometric security */\n    BiometricSecurityStrength[\"Weak\"] = \"weak\";\n    /** Refers to Class 3 - Strong biometric security */\n    BiometricSecurityStrength[\"Strong\"] = \"strong\";\n})(BiometricSecurityStrength || (BiometricSecurityStrength = {}));\n/**\n * When type is set to 'DeviceSecurity', determines which aspects of the device to use to secure the vault.\n * Note: Android only supports `SystemPasscode` on Android 11 and greater.\n * @default `Both`\n */\nvar DeviceSecurityType;\n(function (DeviceSecurityType) {\n    /** Will allow a system passcode to secure the vault. On Android, only supported on Android 11 and greater. */\n    DeviceSecurityType[\"SystemPasscode\"] = \"SystemPasscode\";\n    /** WIll allow biometric hardware tos secure the vault. */\n    DeviceSecurityType[\"Biometrics\"] = \"Biometrics\";\n    /** WIll allow both SystemPasscode or Biometrics as an option to secure the vault. */\n    DeviceSecurityType[\"Both\"] = \"Both\";\n    /** No biometric security option will be used. */\n    DeviceSecurityType[\"None\"] = \"None\";\n})(DeviceSecurityType || (DeviceSecurityType = {}));\n/**\n * The type of vault\n */\nvar VaultType;\n(function (VaultType) {\n    /** No additional security is required in the app as long as the device was unlocked with a secure method. */\n    VaultType[\"SecureStorage\"] = \"SecureStorage\";\n    /** Uses additional device features to add an additional layer of security while the user is in the app. */\n    VaultType[\"DeviceSecurity\"] = \"DeviceSecurity\";\n    /** User will set a custom passcode that will be used to access the vault. */\n    VaultType[\"CustomPasscode\"] = \"CustomPasscode\";\n    /** Data will persist only while the application is in memory. */\n    VaultType[\"InMemory\"] = \"InMemory\";\n})(VaultType || (VaultType = {}));\n/**\n * For Android, when type is {@link VaultType.DeviceSecurity} and deviceSecurityType is {@link DeviceSecurityType.Both}, this options specifies if you want to\n * prefer a Strong Cryptographic Vault or the System Passcode fallback when they both aren't available.\n * @default `StrongVault`\n */\nvar AndroidBiometricCryptoPreference;\n(function (AndroidBiometricCryptoPreference) {\n    /** Prefer to use a strong cryptographic vault. */\n    AndroidBiometricCryptoPreference[\"StrongVault\"] = \"StrongVault\";\n    /** Prefer the system passcode fallback. */\n    AndroidBiometricCryptoPreference[\"SystemPasscode\"] = \"SystemPasscode\";\n})(AndroidBiometricCryptoPreference || (AndroidBiometricCryptoPreference = {}));\n// OLD METHODS\n/**\n * The type of authentication the vault should be configured to allow.\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\nvar AuthMode;\n(function (AuthMode) {\n    /**\n     * Biometrics authentication should only be allowed\n     */\n    AuthMode[AuthMode[\"BiometricOnly\"] = 0] = \"BiometricOnly\";\n    /**\n     * Passcode authentication should only be allowed\n     */\n    AuthMode[AuthMode[\"PasscodeOnly\"] = 1] = \"PasscodeOnly\";\n    /**\n     * Both biometric and passcode authentication should be allowed\n     */\n    AuthMode[AuthMode[\"BiometricAndPasscode\"] = 2] = \"BiometricAndPasscode\";\n    /**\n     * Both biometric and passcode authentication should be disabled.\n     * With this setting all data in the vault will be cleared on lock or\n     * if the app is closed. Stored data is kept only in memory.\n     */\n    AuthMode[AuthMode[\"InMemoryOnly\"] = 3] = \"InMemoryOnly\";\n    /**\n     * Use biometrics if it is available, otherwise use passcode\n     */\n    AuthMode[AuthMode[\"BiometricOrPasscode\"] = 4] = \"BiometricOrPasscode\";\n    /**\n     * Both biometric and passcode authentication will be disabled but any stored values\n     * will persist and be stored securely at rest using the keychain and will be available\n     * without needing to authenticate via passcode or biometrics when the device is unlocked.\n     */\n    AuthMode[AuthMode[\"SecureStorage\"] = 5] = \"SecureStorage\";\n})(AuthMode || (AuthMode = {}));\n\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\nfunction __rest(s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n}\n\nconst STORAGE_KEYS = {\n    DATA: \"data\",\n};\n/**\n * THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER. It only exists\n * as a way to run browser-compatible code in place of Identity Vault. Browsers\n * do not have a secure storage element same as native devices. This class\n * is intended to be used to enable running your application in the browser while\n * simulating the functions of Identity Vault using sessionStorage.\n *\n * Represents a vault implementation for browser compatibility.\n */\nclass BrowserVault {\n    /**\n     * @usage\n     * ```typescript\n     * const vault = new Vault({\n     *  key: 'com.company.myvaultapp',\n     *  type: 'CustomPasscode',\n     *  deviceSecurityType: 'Both',\n     *  lockAfterBackgrounded: 2000,\n     * });\n     * ```\n     * @param config\n     */\n    constructor(config) {\n        /** @ignore */\n        this.isVaultLocked = false;\n        console.warn(\"THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER AND IS NOT INTENDED FOR PRODUCTION USE. It only exists as a way to run browser-compatible code in place of Identity Vault. Browsers do not have a secure storage element same as native devices. This class is intended to be used to enable running your application in the browser while simulating the functions of Identity Vault using sessionStorage.\");\n        this.config = Object.assign({\n            deviceSecurityType: \"Both\",\n            androidBiometricsPreferStrongVaultOrSystemPasscode: \"StrongVault\",\n            shouldClearVaultAfterTooManyFailedAttempts: false,\n            customPasscodeInvalidUnlockAttempts: 5,\n            unlockVaultOnLoad: false,\n        }, config);\n        this.isVaultLocked = config.unlockVaultOnLoad ? false : true;\n    }\n    /** See {@link Vault.doesVaultExist} */\n    doesVaultExist() {\n        const data = this.getDataObj();\n        return Promise.resolve(!!data);\n    }\n    /** See {@link Vault.clear} */\n    clear() {\n        this.unlockIfLocked();\n        sessionStorage.removeItem(this.getKey(STORAGE_KEYS.DATA));\n        return Promise.resolve();\n    }\n    /** See {@link Vault.exportVault} */\n    exportVault() {\n        this.unlockIfLocked();\n        const data = this.getDataObj();\n        return Promise.resolve(data !== null && data !== void 0 ? data : {});\n    }\n    /** See {@link Vault.importVault} */\n    importVault(data) {\n        this.setDataObj(data);\n        return Promise.resolve();\n    }\n    /** See {@link Vault.isLocked} */\n    isLocked() {\n        return Promise.resolve(this.isVaultLocked);\n    }\n    /** See {@link Vault.getKeys} */\n    getKeys() {\n        this.unlockIfLocked();\n        const data = this.getDataObj();\n        if (!data)\n            return Promise.resolve([]);\n        return Promise.resolve(Object.keys(data));\n    }\n    /** See {@link Vault.getValue} */\n    getValue(key) {\n        var _a;\n        this.unlockIfLocked();\n        const data = this.getDataObj();\n        return Promise.resolve((_a = data === null || data === void 0 ? void 0 : data[key]) !== null && _a !== void 0 ? _a : null);\n    }\n    /** See {@link Vault.lock} */\n    lock() {\n        var _a;\n        (_a = this.lockCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n        return Promise.resolve();\n    }\n    /** See {@link Vault.removeValue} */\n    removeValue(key) {\n        this.unlockIfLocked();\n        const data = this.getDataObj();\n        if (!data)\n            return Promise.resolve();\n        const _a = data, _b = key; _a[_b]; const dataAfterRemoval = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n        this.setDataObj(dataAfterRemoval);\n        return Promise.resolve();\n    }\n    /** See {@link Vault.setCustomPasscode} */\n    setCustomPasscode(passcode) {\n        return Promise.resolve();\n    }\n    /** See {@link Vault.setValue} */\n    setValue(key, value) {\n        this.unlockIfLocked();\n        const data = this.getDataObj();\n        if (!data) {\n            this.setDataObj({ [key]: value });\n        }\n        else {\n            this.setDataObj(Object.assign(Object.assign({}, data), { [key]: value }));\n        }\n        return Promise.resolve();\n    }\n    /** See {@link Vault.onConfigChanged} */\n    onConfigChanged(callback) {\n        this.configCallback = callback;\n    }\n    /** See {@link Vault.onError} */\n    onError(callback) {\n        this.errorCallback = callback;\n    }\n    /** See {@link Vault.onLock} */\n    onLock(callback) {\n        this.lockCallback = callback;\n    }\n    /** See {@link Vault.onPasscodeRequested} */\n    onPasscodeRequested(callback) {\n        // No passcode support\n    }\n    /** See {@link Vault.onUnlock} */\n    onUnlock(callback) {\n        this.unlockCallback = callback;\n    }\n    /** See {@link Vault.unlock} */\n    unlock() {\n        var _a;\n        (_a = this.unlockCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n        return Promise.resolve();\n    }\n    /** See {@link Vault.updateConfig} */\n    updateConfig(config) {\n        var _a;\n        this.config = config;\n        (_a = this.configCallback) === null || _a === void 0 ? void 0 : _a.call(this, config);\n        return Promise.resolve();\n    }\n    /** @ignore */\n    requestBiometricPrompt() {\n        this.unlockIfLocked();\n        return Promise.resolve(true);\n    }\n    /** @ignore */\n    unlockIfLocked() {\n        if (this.isVaultLocked) {\n            this.unlock();\n        }\n    }\n    /** @ignore */\n    getDataObj() {\n        var _a;\n        const value = sessionStorage.getItem(this.getKey(STORAGE_KEYS.DATA));\n        if (!value)\n            return null;\n        try {\n            return JSON.parse(value);\n        }\n        catch (e) {\n            (_a = this.errorCallback) === null || _a === void 0 ? void 0 : _a.call(this, {\n                message: \"Unable to parse data store\",\n                code: VaultErrorCodes.Unknown,\n            });\n            return null;\n        }\n    }\n    /** @ignore */\n    setDataObj(data) {\n        var _a;\n        try {\n            const dataStr = JSON.stringify(data);\n            sessionStorage.setItem(this.getKey(STORAGE_KEYS.DATA), dataStr);\n        }\n        catch (e) {\n            (_a = this.errorCallback) === null || _a === void 0 ? void 0 : _a.call(this, {\n                message: \"Unable to serialize data\",\n                code: VaultErrorCodes.Unknown,\n            });\n        }\n    }\n    /** @ignore */\n    getKey(key) {\n        return `IV-${this.config.key}-${key}`;\n    }\n}\n\n/**\n * Represents a vault for secure value storage\n */\nclass Vault {\n    /**\n     * @usage\n     * ```typescript\n     * const vault = new Vault({\n     *  key: 'com.company.myvaultapp',\n     *  type: 'CustomPasscode',\n     *  deviceSecurityType: DeviceSecurityType.None,\n     *  lockAfterBackgrounded: 2000,\n     * });\n     * ```\n     * @param config\n     */\n    constructor(config) {\n        /** @ignore */\n        this.defaultConfig = {\n            deviceSecurityType: DeviceSecurityType.None,\n            androidBiometricsPreferStrongVaultOrSystemPasscode: AndroidBiometricCryptoPreference.StrongVault,\n            shouldClearVaultAfterTooManyFailedAttempts: false,\n            customPasscodeInvalidUnlockAttempts: 5,\n            unlockVaultOnLoad: false,\n        };\n        // set defaults\n        this.config = Object.assign(this.defaultConfig, config);\n        // setting sane defaults\n        if (config.deviceSecurityType === DeviceSecurityType.None &&\n            config.type === VaultType.DeviceSecurity) {\n            config.deviceSecurityType = DeviceSecurityType.Both;\n        }\n        this.resume = this.resume.bind(this);\n        this.handleError = this.handleError.bind(this);\n        this.setup().then(() => {\n            this.getPersistedVaultConfig();\n        });\n    }\n    /**\n     * Resolves true if a vault with the same key already exists, and false if not.\n     * The vault does not need to be unlocked to check.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * const vaultExists = await vault.doesVaultExists()\n     * if (!vaultExists) {\n     *  // the vault does not exist...\n     * }\n     * ```\n     */\n    doesVaultExist() {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                this.handleError(resolve, reject, error, () => this.doesVaultExist());\n            }, \"VaultPlugin\", \"doesVaultExist\", [this.config]);\n        });\n    }\n    /**\n     * Clears out the current vault and removes it from the system.\n     * Note: The vault does not need to be unlocked in order to clear it. No credentials are checked\n     * when clearing the vault.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * await vault.clear();\n     * ```\n     */\n    clear() {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                resolve();\n            }, (error) => {\n                this.handleError(resolve, reject, error, () => this.clear());\n            }, \"VaultPlugin\", \"clear\", [this.config]);\n        });\n    }\n    /**\n     * Exports the data of the current vault in its entirety.\n     * The data is a map with keys that are strings and values that are JSON.\n     * Calling `exportVault` will attempt to unlock the vault if it is currently locked.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * const data = await vault.exportVault();\n     * ```\n     *\n     * @return The resolved object is a map with string keys and string values.\n     *\n     */\n    exportVault() {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                this.handleError(resolve, reject, error, () => this.exportVault());\n            }, \"VaultPlugin\", \"exportVault\", [this.config]);\n        });\n    }\n    /**\n     * Imports data into the vault, replacing the current contents of the vault.\n     * The data is a map with keys that are strings and values that are JSON.\n     * Calling `importVault` will attempt to unlock the vault if it is currently locked.\n     *\n     * @usage\n     * ```typescript\n     * const dataFromElsewhere = await getUserData();\n     * const newVault = new Vault(vaultConfig);\n     * await newVault.importVault(dataFromElsewhere);\n     * ```\n     *\n     * @param data The entire data object to be imported. The shape of data must be {[key: string]: string}.\n     *\n     */\n    importVault(data) {\n        const jsonData = JSON.stringify(data);\n        return new Promise((resolve, reject) => {\n            cordova.exec(resolve, (error) => {\n                this.handleError(resolve, reject, error, () => this.importVault(data));\n            }, \"VaultPlugin\", \"importVault\", [this.config, jsonData]);\n        });\n    }\n    /**\n     * Checks if the vault is currently in a locked state, which signifies that the contents\n     * of the secure vault are not currently accessible. `isLocked` can also return true if the\n     * vault does not exist.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * const locked = await vault.isLocked();\n     * if (locked) {\n     *  // vault is locked (or does not exist);\n     * }\n     * ```\n     */\n    isLocked() {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                this.handleError(resolve, reject, error);\n            }, \"VaultPlugin\", \"isLocked\", [this.config]);\n        });\n    }\n    /**\n     * Returns an array of keys that are currently in the vault.\n     * Calling `getKeys` will attempt to unlock the vault if it is currently locked.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * const allKeys = await vault.getKeys();\n     * allKeys.forEach((key) => {\n     *  // do something with the key\n     * });\n     * ```\n     */\n    getKeys() {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                this.handleError(resolve, reject, error, () => this.getKeys());\n            }, \"VaultPlugin\", \"getKeys\", [this.config]);\n        });\n    }\n    /**\n     * Gets the value for a given key. Returns null if the key does not exist.\n     * Calling `getValue` will attempt to unlock the vault if it is currently locked.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * const userFirstName = await vault.getValue<string>(\"firstname\");\n     * ```\n     *\n     * @param key The key to look up the value for\n     *\n     */\n    getValue(key) {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                if (!data) {\n                    // android returns null as an empty string, so manually convert it here\n                    resolve(null);\n                }\n                else {\n                    try {\n                        resolve(JSON.parse(data));\n                    }\n                    catch (err) {\n                        resolve(data);\n                    }\n                }\n            }, (error) => {\n                this.handleError(resolve, reject, error, () => this.getValue(key));\n            }, \"VaultPlugin\", \"getValue\", [this.config, key]);\n        });\n    }\n    /**\n     * Locks the vault if it is currently unlocked.\n     * Locking the vault with remove all secure data from memory inside of Identity Vault, but not your application.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * await vault.lock();\n     * ```\n     */\n    lock() {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                resolve();\n            }, (error) => {\n                this.handleError(resolve, reject, error);\n            }, \"VaultPlugin\", \"lock\", [this.config]);\n        });\n    }\n    /**\n     * Removes a value from the vault.\n     * Calling `removeValue` will attempt to unlock the vault if it is currently locked.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * await vault.removeValue(\"address\");\n     * ```\n     *\n     * @param key The key to remove\n     *\n     */\n    removeValue(key) {\n        return new Promise((resolve, reject) => {\n            cordova.exec(resolve, (error) => {\n                this.handleError(resolve, reject, error, () => this.removeValue(key));\n            }, \"VaultPlugin\", \"removeValue\", [this.config, key]);\n        });\n    }\n    /**\n     * When the vault type is set to 'CustomPasscode', this method sets the passcode required to\n     * secure the vault.\n     * This method is typically called in the `onPasscodeRequested` callback.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * const code = window.prompt(\"Enter your passcode.\");\n     * if (code) {\n     *  await vault.setCustomPasscode(code);\n     * }\n     * ```\n     *\n     * @param passcode The user supplied passcode to secure the vault with.\n     *\n     */\n    setCustomPasscode(passcode) {\n        return new Promise((resolve, reject) => {\n            cordova.exec(resolve, (error) => {\n                this.handleError(resolve, reject, error);\n            }, \"VaultPlugin\", \"setCustomPasscode\", [this.config, passcode]);\n        });\n    }\n    /**\n     * Sets the value of an item in the vault.\n     * Calling `setValue` will attempt to unlock the vault if it is currently locked.\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * await vault.setValue<string>(\"theme\", theme);\n     * ```\n     *\n     * @param key The key for the new value.\n     * @param value The value to store in the vault. Value can be of any type, as it will be parsed to JSON in the vault.\n     *\n     */\n    setValue(key, value) {\n        const jsonValue = JSON.stringify(value);\n        return new Promise((resolve, reject) => {\n            cordova.exec(resolve, (error) => {\n                this.handleError(resolve, reject, error, () => this.setValue(key, value));\n            }, \"VaultPlugin\", \"setValue\", [this.config, key, jsonValue]);\n        });\n    }\n    /**\n     * Triggers when a config change occurs.\n     *\n     * @usage\n     * ```typescript\n     * vault.onConfigChanged((config) => {\n     *  console.log(\"updated config: \", config);\n     * });\n     * ```\n     * @param callback The callback function that will be called when the event triggers. Passes in the current vault config.\n     *\n     */\n    onConfigChanged(callback) {\n        cordova.exec((data) => {\n            callback(JSON.parse(data));\n        }, (error) => console.error(error), \"VaultPlugin\", \"onConfigChanged\", []);\n    }\n    /**\n     * Triggers when an error occurs in the application.\n     * Errors that come back as rejected promises also trigger this event.\n     *\n     * @usage\n     * ```typescript\n     * vault.onError((err) => {\n     *  console.log('ERROR from callback', JSON.stringify(err));\n     * });\n     * ```\n     *\n     * @param callback The callback function that will be called when the event triggers. Passes in the error object.\n     *\n     */\n    onError(callback) {\n        cordova.exec(() => { }, callback, \"VaultPlugin\", \"onError\", []);\n    }\n    /**\n     * Triggers when the vault enters a locked state.\n     *\n     * @usage\n     * ```typescript\n     * vault.onLock(() => { displayNotification(\"Vault locked.\"); })\n     * ```\n     *\n     * @param callback The callback function that will be called when the event triggers.\n     *\n     */\n    onLock(callback) {\n        cordova.exec(callback, (error) => console.error(error), \"VaultPlugin\", \"onLock\", [this.config]);\n    }\n    /**\n     * For CustomPasscode vaults, this event triggers when the vault is attempting to unlock\n     * and the passcode has not been set yet. The callback function will pass in a Promise that,\n     * when resolved, with attempt to unlock the vault again calling the same method that originally\n     * tried to unlock the vault. Before the promise is resolved, you should prompt the user to supply a passcode, and\n     * then supply that value to `setCustomPasscode`.\n     *\n     * @usage\n     * ```typescript\n     * vault.onPasscodeRequested(async (isPasscodeSetRequest) => {\n     *  const message = isPasscodeSetRequest\n     *    ? 'Setup Passcode' // passcode is being set for first time\n     *    : 'Enter passcode'; // passcode is being asked for unlock\n     *  const passcode = window.prompt(message) || '';\n     *   vault.setCustomPasscode(passcode);\n     *   return Promise.resolve();\n     * });\n     * ```\n     *\n     * @param callback The callback function that will be called when the event triggers. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.\n     *\n     */\n    onPasscodeRequested(callback) {\n        this.passCodeRequestedCallback = callback;\n    }\n    /**\n     * Triggers when the vault enters an unlocked state.\n     *\n     * @usage\n     * ```typescript\n     * vault.onUnlock(() => {\n     *  console.log(\"vault is now unlocked\");\n     * });\n     * ```\n     * @param callback The callback function that will be called when the event triggers.\n     *\n     */\n    onUnlock(callback) {\n        cordova.exec(callback, (error) => console.error(error), \"VaultPlugin\", \"onUnlock\", [this.config]);\n    }\n    /**\n     * Manually unlock the vault. Will trigger any authentication mechanism needed to access the vault (passcode, biometrics, etc..).\n     *\n     * @usage\n     * ```typescript\n     * const vault = new Vault(existingVaultConfig);\n     * await vault.unlock();\n     * ```\n     */\n    unlock() {\n        return new Promise((resolve, reject) => {\n            cordova.exec(() => {\n                resolve();\n            }, (error) => {\n                this.handleError(resolve, reject, error, () => this.unlock());\n            }, \"VaultPlugin\", \"unlock\", [this.config]);\n        });\n    }\n    /**\n     * Updates the configuration of the current vault.\n     *\n     *  @usage\n     * ```typescript\n     * async function changeVaultType(type: VaultType) {\n     *  const vault = new Vault(this.existingVaultConfig);\n     *  const newConfig = { ...this.existingVaultConfig, type };\n     *  await vault.updateConfig(newConfig);\n     *  this.existingVaultConfig = newConfig;\n     * }\n     * ```\n     *\n     * @param config The new config\n     *\n     */\n    updateConfig(config) {\n        return new Promise((resolve, reject) => {\n            config = Object.assign(this.defaultConfig, config);\n            // setting sane defaults\n            if (config.deviceSecurityType === DeviceSecurityType.None &&\n                config.type === VaultType.DeviceSecurity) {\n                config.deviceSecurityType = DeviceSecurityType.Both;\n            }\n            cordova.exec(() => {\n                this.config = config;\n                resolve();\n            }, (error) => {\n                this.handleError(resolve, reject, error, () => this.updateConfig(config));\n            }, \"VaultPlugin\", \"updateConfig\", [config]);\n        });\n    }\n    /** @ignore */\n    async handleError(resolve, reject, error, retryFunc) {\n        if (error.code === VaultErrorCodes.MissingPasscode &&\n            this.passCodeRequestedCallback) {\n            await this.passCodeRequestedCallback(error.extra.isPasscodeSetRequest);\n            if (retryFunc) {\n                try {\n                    const data = await retryFunc();\n                    resolve(data);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n        }\n        else if (error.code === VaultErrorCodes.MissingBiometrics) {\n            cordova.exec(async () => {\n                const data = await retryFunc();\n                resolve(data);\n            }, (e) => reject(e), \"VaultPlugin\", \"requestBiometricPrompt\", [this.config]);\n        }\n        else {\n            reject(error);\n        }\n    }\n    /** @ignore */\n    requestBiometricPrompt() {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                this.handleError(resolve, reject, error, () => this.requestBiometricPrompt());\n            }, \"VaultPlugin\", \"requestBiometricPrompt\", [this.config]);\n        });\n    }\n    /**\n     * @ignore\n     */\n    resume() {\n        const noop = () => { };\n        cordova.exec(noop, (error) => {\n            this.handleError(noop, noop, error, () => this.resume());\n        }, \"VaultPlugin\", \"appResumed\", [this.config]);\n    }\n    /**\n     * @ignore\n     */\n    setup() {\n        return new Promise((resolve, reject) => {\n            document.addEventListener(\"resume\", this.resume, false);\n            cordova.exec(resolve, (error) => {\n                this.handleError(resolve, reject, error);\n            }, \"VaultPlugin\", \"setup\", [this.config]);\n        });\n    }\n    /**\n     * @ignore\n     */\n    getPersistedVaultConfig() {\n        return new Promise((resolve, reject) => {\n            cordova.exec((data) => {\n                if (!data) {\n                    resolve();\n                }\n                else {\n                    const vaultConfig = JSON.parse(data);\n                    this.config = Object.assign(this.config, vaultConfig);\n                    resolve();\n                }\n            }, (error) => {\n                this.handleError(resolve, reject, error);\n            }, \"VaultPlugin\", \"getVaultConfig\", [this.config]);\n        });\n    }\n}\n\nclass Device {\n    /** @ignore */\n    constructor() { }\n    /**\n     * Gets the types of biometrics the device supports.\n     *\n     * @usage\n     * ```typescript\n     * const hardware = await Device.getAvailableHardware();\n     * hardware.forEach((biometricType) => console.log(\"Type: \" + biometricType));\n     * ```\n     */\n    static getAvailableHardware() {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve([]);\n                return;\n            }\n            cordova.exec((data) => {\n                resolve(data);\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"getAvailableHardware\", []);\n        });\n    }\n    /**\n     * Check whether biometrics are locked out on the device.\n     *\n     * On Android, the locked out state will only known after an attempted biometric unlock.\n     *\n     * @usage\n     * ```typescript\n     * const isLockedOut = await Device.isLockedOutOfBiometrics();\n     * if (isLockedOut) {\n     *  // device is locked out ...\n     * }\n     * ```\n     */\n    static isLockedOutOfBiometrics() {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve(false);\n                return;\n            }\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"isLockedOutOfBiometrics\", []);\n        });\n    }\n    /**\n     * Checks the device biometric strength level.\n     *\n     * On iOS this will always return 'strong'.\n     *\n     * @usage\n     * ```typescript\n     * const biometricStrength = await Device.getBiometricStrengthLevel();\n     * ```\n     */\n    static getBiometricStrengthLevel() {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve(BiometricSecurityStrength.Weak);\n                return;\n            }\n            cordova.exec((data) => {\n                resolve(data);\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"getBiometricStrengthLevel\", []);\n        });\n    }\n    /**\n     * Check whether or not the screen will be obscured in app switcher mode.\n     *\n     * @usage\n     * ```typescript\n     * const willHideScreen = await Device.isHideScreenOnBackgroundEnabled();\n     * ```\n     */\n    static isHideScreenOnBackgroundEnabled() {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve(false);\n                return;\n            }\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"isHideScreenOnBackgroundEnabled\", []);\n        });\n    }\n    /**\n     * Set whether or not the screen will be obscured in app switcher mode\n     *\n     * @usage\n     * ```typescript\n     * await Device.setHideScreenOnBackground(true);\n     * ```\n     */\n    static setHideScreenOnBackground(enabled) {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve();\n                return;\n            }\n            cordova.exec(() => {\n                resolve();\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"setHideScreenOnBackground\", [enabled]);\n        });\n    }\n    /**\n     * Check whether the device OS-level passcode has been set.\n     *\n     * @usage\n     * ```typescript\n     * const hasSystemPasscode = await Device.isSystemPasscodeSet();\n     * if (hasSystemPasscode) {\n     *  // device has a system passcode\n     * }\n     * ```\n     */\n    static isSystemPasscodeSet() {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve(false);\n                return;\n            }\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"isSystemPasscodeSet\", []);\n        });\n    }\n    /**\n     * Check whether or not biometrics is supported by the device and has been configured by the current user of the device.\n     *\n     * @usage\n     * ```typescript\n     * const biometricsEnabled = await Device.isBiometricsEnabled();\n     * if (!biometricsEnabled) {\n     *  // biometrics not enabled on this device...\n     * }\n     * ```\n     */\n    static isBiometricsEnabled() {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve(false);\n                return;\n            }\n            cordova.exec((data) => {\n                console.log(\"biometrics is enabled: \", data);\n                resolve(JSON.parse(data));\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"isBiometricsEnabled\", []);\n        });\n    }\n    /**\n     * Check whether or not biometrics is supported by the device.\n     *\n     * @usage\n     * ```typescript\n     * const biometricsSupported = await Device.isBiometricsSupported();\n     * if (biometricsSupported) {\n     *   // biometrics is supported on this device...\n     * }\n     * ```\n     */\n    static isBiometricsSupported() {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve(false);\n                return;\n            }\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"isBiometricsSupported\", []);\n        });\n    }\n    /**\n     * Check if the device has a secure hardware enclave.\n     *\n     * @usage\n     * ```typescript\n     * const hasSecureHardware = await Device.hasSecureHardware();\n     * if (!hasSecureHardware) {\n     *    // this device doesn't have secure hardware\n     * }\n     * ```\n     */\n    static hasSecureHardware() {\n        return new Promise((resolve, reject) => {\n            if (!(\"cordova\" in window)) {\n                resolve(false);\n                return;\n            }\n            cordova.exec((data) => {\n                resolve(JSON.parse(data));\n            }, (error) => {\n                Device.handleError(resolve, reject, error);\n            }, \"DevicePlugin\", \"hasSecureHardware\", []);\n        });\n    }\n    /**\n     * @ignore\n     */\n    static async handleError(resolve, reject, error, retryFunc) {\n        reject(error);\n    }\n}\n\n/**\n * @hidden\n *\n * @ignore\n */\nclass IonicIdentityVaultUser {\n    constructor(platform, options, descriptor) {\n        this.platform = platform;\n        this.options = options;\n        this._readyCalled = false;\n        this.descriptor = descriptor || { username: '_lastUser', vaultId: 'default' };\n        this._readyPromise = this.initializeVault();\n    }\n    get token() {\n        const session = this.session;\n        return session && session.token;\n    }\n    get username() {\n        const session = this.session;\n        return session && session.username;\n    }\n    get config() {\n        if (!this._config) {\n            return undefined;\n        }\n        let authMode;\n        const bioEnabled = this._config.isBiometricsEnabled;\n        const passEnabled = this._config.isPasscodeEnabled;\n        const secureStorageMode = this._config.isSecureStorageModeEnabled;\n        if (secureStorageMode) {\n            authMode = AuthMode.SecureStorage;\n        }\n        else if (bioEnabled && passEnabled) {\n            authMode = AuthMode.BiometricAndPasscode;\n        }\n        else if (bioEnabled && !passEnabled) {\n            authMode = AuthMode.BiometricOnly;\n        }\n        else if (!bioEnabled && passEnabled) {\n            authMode = AuthMode.PasscodeOnly;\n        }\n        else if (!bioEnabled && !passEnabled) {\n            authMode = AuthMode.InMemoryOnly;\n        }\n        return {\n            authMode: authMode,\n            isPasscodeSetupNeeded: this._config.isPasscodeSetupNeeded,\n            lockAfter: this._config.lockAfter,\n            hideScreenOnBackground: this._config.hideScreenOnBackground,\n        };\n    }\n    // overidable event handlers\n    onVaultLocked(_event) { }\n    onSessionRestoreError(_err) { }\n    onUnlockOnReadyError(_err) { }\n    onVaultUnlocked(_config) { }\n    onVaultReady(_config) { }\n    onSetupError(_error) { }\n    onConfigChange(_config) { }\n    ;\n    onSessionRestored(_session) { }\n    ;\n    async onPasscodeRequest(_isPasscodeSetRequest) { return; }\n    ;\n    async onReady(vault) {\n        if (this._readyCalled) {\n            return;\n        }\n        this._readyCalled = true;\n        this.vault = vault;\n        const inUse = await this.vault.isInUse();\n        this._config = vault.config;\n        const locked = await this.vault.isLocked();\n        let restoreSessionError;\n        try {\n            if (this.options.restoreSessionOnReady && inUse) {\n                await this._restoreSession();\n            }\n        }\n        catch (e) {\n            restoreSessionError = e;\n        }\n        let unlockOnReadyError;\n        try {\n            if (locked && this.options.unlockOnReady) {\n                await this._unlock();\n            }\n        }\n        catch (e) {\n            unlockOnReadyError = e;\n        }\n        // Note Swallow all errors in init like Vault is Locked Etc.\n        try {\n            if (!inUse) {\n                await this._trySetAuthMode(this.options.authMode);\n            }\n        }\n        catch (e) { }\n        this._readyResolve();\n        this.onVaultReady(this.config);\n        if (restoreSessionError) {\n            this.onSessionRestoreError(restoreSessionError);\n        }\n        if (unlockOnReadyError) {\n            this.onUnlockOnReadyError(restoreSessionError);\n        }\n    }\n    onLock(event) {\n        this.session = undefined;\n        this.onVaultLocked(event);\n    }\n    async onUnlock(config) {\n        await this.ready();\n        this._config = config;\n        this.onVaultUnlocked(this.config);\n    }\n    onError(error) {\n        this._readyReject(error);\n        this.onSetupError(error);\n    }\n    onConfig(config) {\n        this._config = config;\n        this.onConfigChange(this.config);\n    }\n    async ready() {\n        return this._readyPromise;\n    }\n    async _unlock(authMode) {\n        const locked = await this.vault.isLocked();\n        if (!locked) {\n            return;\n        }\n        authMode = authMode !== undefined && authMode !== AuthMode.BiometricOrPasscode ? authMode : this.config.authMode;\n        switch (authMode) {\n            case AuthMode.BiometricOnly:\n                return this.vault.unlock();\n            case AuthMode.PasscodeOnly:\n                return this.unlockWithPasscode();\n            case AuthMode.BiometricAndPasscode:\n                try {\n                    await this.vault.unlock();\n                    return;\n                }\n                catch (e) {\n                    const handleableErrors = [\n                        VaultErrorCodes.AuthFailed,\n                        VaultErrorCodes.BiometricsNotEnabled,\n                        VaultErrorCodes.UserCanceledInteraction,\n                        VaultErrorCodes.InvalidatedCredential,\n                    ];\n                    if (handleableErrors.indexOf(e.code) > -1) {\n                        await this.unlockWithPasscode();\n                        // The user removed fingerprints/faceID and so the bio creds are gone\n                        // if they are using passcode auth we can resave the credential to autoreset\n                        // the mode to PasscodeOnly if bio is no longer available.\n                        if (e.code === VaultErrorCodes.InvalidatedCredential) {\n                            const session = await this.restoreSession();\n                            await this.saveSession(session);\n                        }\n                        return;\n                    }\n                    throw e;\n                }\n        }\n    }\n    async unlock(authMode) {\n        await this.ready();\n        return this._unlock(authMode);\n    }\n    async unlockWithPasscode() {\n        const passcode = await this.onPasscodeRequest(false);\n        return this.vault.unlock(true, passcode);\n    }\n    async _setPasscode() {\n        const locked = await this.vault.isLocked();\n        if (locked) {\n            throw { code: VaultErrorCodes.VaultLocked, message: \"Operation not allowed while vault locked.\" };\n        }\n        const passcode = await this.onPasscodeRequest(true);\n        return this.vault.setPasscode(passcode);\n    }\n    async setPasscode() {\n        await this.ready();\n        return this._setPasscode();\n    }\n    async getSession() {\n        await this.ready();\n        if (this.options.unlockOnAccess) {\n            await this._unlock();\n        }\n        return this.session;\n    }\n    async _restoreSession() {\n        const inUse = await this.vault.isInUse();\n        if (!inUse) {\n            return;\n        }\n        if (this.options.unlockOnAccess) {\n            await this._unlock();\n        }\n        this.session = await this.vault.getValue('session');\n        this.onSessionRestored(this.session);\n        return this.session;\n    }\n    async restoreSession() {\n        await this.ready();\n        return this._restoreSession();\n    }\n    async saveSession(session) {\n        await this.ready();\n        if (this.config.isPasscodeSetupNeeded) {\n            await this.setPasscode();\n        }\n        try {\n            await this.vault.storeValue('session', session);\n        }\n        catch (e) {\n            // Catch the case where Biometrics with Passcode Fallback\n            // was enabled but the user disabled passcode or removed their\n            // fingerprints/faceid and try to recover by setting to passcode only\n            // mode.\n            if (e.code === VaultErrorCodes.SecurityNotAvailable) {\n                const authMode = await this.getAuthMode();\n                if (authMode === AuthMode.BiometricAndPasscode) {\n                    await this.setAuthMode(AuthMode.PasscodeOnly);\n                    return this.saveSession(session);\n                }\n            }\n            throw e;\n        }\n        this.session = session;\n    }\n    async login(session, authMode) {\n        await this.ready();\n        await this.logout();\n        await this._trySetAuthMode(authMode);\n        return this.saveSession(session);\n    }\n    async getVault() {\n        await this.ready();\n        return this.vault;\n    }\n    async initializeVault() {\n        await this.platform.ready();\n        if (this.vault != null) {\n            return Promise.resolve();\n        }\n        if (this.vIonicNativeAuth == null) {\n            this.vIonicNativeAuth = this.getPlugin();\n        }\n        const readyPromise = new Promise((resolve, reject) => {\n            this._readyResolve = resolve;\n            this._readyReject = reject;\n        });\n        const { lockAfter, hideScreenOnBackground, shouldClearVaultAfterTooManyFailedAttempts, allowSystemPinFallback, androidPromptNegativeButtonText, androidPromptTitle, androidPromptSubtitle, androidPromptDescription, iosPromptText } = this.options;\n        this.vault = this.vIonicNativeAuth.getVault(Object.assign(Object.assign({ lockAfter,\n            hideScreenOnBackground,\n            shouldClearVaultAfterTooManyFailedAttempts,\n            allowSystemPinFallback,\n            androidPromptNegativeButtonText,\n            androidPromptTitle,\n            androidPromptSubtitle,\n            androidPromptDescription,\n            iosPromptText }, this.descriptor), { onLock: this.onLock.bind(this), onConfig: this.onConfig.bind(this), onError: this.onError.bind(this), onUnlock: this.onUnlock.bind(this), onReady: this.onReady.bind(this) }));\n        return readyPromise;\n    }\n    getPlugin() {\n        return IonicNativeAuth;\n    }\n    async getBiometricType() {\n        await this.ready();\n        return this.vault.getBiometricType();\n    }\n    async getAvailableHardware() {\n        await this.ready();\n        return this.vault.getAvailableHardware();\n    }\n    async lockOut() {\n        await this.ready();\n        await this.vault.lock();\n        this.session = undefined;\n    }\n    async logout() {\n        await this.ready();\n        await this.vault.clear();\n        this.session = undefined;\n        this._config = await this.vault.getConfig();\n    }\n    async hasStoredSession() {\n        await this.ready();\n        return this.vault.isInUse();\n    }\n    async setBiometricsEnabled(isBiometricsEnabled) {\n        await this.ready();\n        return this._setBiometricsEnabled(isBiometricsEnabled);\n    }\n    async _setBiometricsEnabled(isBiometricsEnabled) {\n        return this.vault.setBiometricsEnabled(isBiometricsEnabled);\n    }\n    async setHideScreenOnBackground(enabled) {\n        await this.ready();\n        return this.vault.setHideScreenOnBackground(enabled);\n    }\n    async setPasscodeEnabled(isPasscodeEnabled) {\n        await this.ready();\n        await this._setPasscodeEnabled(isPasscodeEnabled);\n    }\n    async _setPasscodeEnabled(isPasscodeEnabled) {\n        await this.vault.setPasscodeEnabled(isPasscodeEnabled);\n        this._config = await this.vault.getConfig();\n        if (this.config.isPasscodeSetupNeeded) {\n            await this._setPasscode();\n        }\n    }\n    async isBiometricsEnabled() {\n        await this.ready();\n        return this.vault.isBiometricsEnabled();\n    }\n    async isBiometricsAvailable() {\n        await this.ready();\n        return this.vault.isBiometricsAvailable();\n    }\n    async isBiometricsSupported() {\n        await this.ready();\n        return this.vault.isBiometricsSupported();\n    }\n    async isSecureStorageModeEnabled() {\n        await this.ready();\n        return this.vault.isSecureStorageModeEnabled();\n    }\n    async isPasscodeEnabled() {\n        await this.ready();\n        return this.vault.isPasscodeEnabled();\n    }\n    async _setAuthMode(authMode) {\n        authMode = authMode !== undefined ? authMode : this.config.authMode;\n        if (authMode === this.config.authMode) {\n            return;\n        }\n        switch (authMode) {\n            case AuthMode.BiometricOnly:\n                await this._setBiometricsEnabled(true);\n                await this._setPasscodeEnabled(false);\n                break;\n            case AuthMode.PasscodeOnly:\n                await this._setPasscodeEnabled(true);\n                await this._setBiometricsEnabled(false);\n                break;\n            case AuthMode.BiometricAndPasscode:\n                await this._setPasscodeEnabled(true);\n                await this._setBiometricsEnabled(true);\n                break;\n            case AuthMode.BiometricOrPasscode:\n                try {\n                    await this._setBiometricsEnabled(true);\n                    await this._setPasscodeEnabled(false);\n                }\n                catch (error) {\n                    await this._setPasscodeEnabled(true);\n                }\n                break;\n            case AuthMode.InMemoryOnly:\n                await this._setPasscodeEnabled(false);\n                await this._setBiometricsEnabled(false);\n                await this.vault.setSecureStorageModeEnabled(false);\n                break;\n            case AuthMode.SecureStorage:\n                // Note: Setting this mode automatically disables the other modes in native code.\n                await this.vault.setSecureStorageModeEnabled(true);\n                break;\n            default:\n                throw { code: VaultErrorCodes.InvalidAuthMode, message: \"Invalid AuthMode\" };\n        }\n    }\n    async _trySetAuthMode(authMode) {\n        try {\n            await this._setAuthMode(authMode);\n        }\n        catch (error) {\n            if (error.code !== VaultErrorCodes.BiometricsNotEnabled &&\n                error.code !== VaultErrorCodes.SecurityNotAvailable) {\n                throw error;\n            }\n        }\n    }\n    async setAuthMode(authMode) {\n        await this.ready();\n        return this._setAuthMode(authMode);\n    }\n    async getAuthMode() {\n        await this.ready();\n        this._config = await this.vault.getConfig();\n        return this.config.authMode;\n    }\n}\n\nclass MigratorVault extends IonicIdentityVaultUser {\n    constructor(options, onPasscodeRequest, descriptor) {\n        super({\n            ready: () => Promise.resolve(true),\n        }, options, descriptor);\n        if (onPasscodeRequest) {\n            this.onPasscodeRequest = onPasscodeRequest;\n        }\n    }\n    static getInstance(options, onPasscodeRequest, descriptor) {\n        if (!MigratorVault.instance) {\n            MigratorVault.instance = new MigratorVault(options, onPasscodeRequest, descriptor);\n        }\n        return MigratorVault.instance;\n    }\n}\nMigratorVault.instance = undefined;\nclass VaultMigrator {\n    /**\n     *\n     * @usage\n     * ```typescript\n     * const legacyVaultConfig = {\n     *  unlockOnAccess: true,\n     *  hideScreenOnBackground: true,\n     *  lockAfter: 5000,\n     *  // and more ....\n     * }\n     * const migrator = new VaultMigrator(legacyVaultConfig, customPasscodePrompt);\n     * ```\n     * @param options The legacy vault configuration options\n     * @param onPasscodeRequest An optional callback function that will be called when the vault attempts to request a passcode. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.\n     * @param descriptor An optional interface that describes the legacy vault.\n     */\n    constructor(options, onPasscodeRequest, descriptor) {\n        this.migratorSession = MigratorVault.getInstance(options, onPasscodeRequest, descriptor);\n    }\n    /**\n     * Exports the data of the legacy vault in its entirety.\n     *\n     * @usage\n     * ```typescript\n     * const data = await migrator.exportVault();\n     * console.log(\"@@VAULT DATA: \", JSON.stringify(data));\n     * ```\n     * @returns\n     */\n    async exportVault() {\n        if (!(await this.migratorSession.hasStoredSession())) {\n            throw Error(\"no data in legacy vault\");\n        }\n        await this.migratorSession.unlock();\n        const vault = await this.migratorSession.getVault();\n        const keys = await vault.getKeys();\n        let vaultData = {};\n        for (let i = 0; i < keys.length; i++) {\n            const keyValue = await vault.getValue(keys[i]);\n            vaultData[keys[i]] = keyValue;\n        }\n        return vaultData;\n    }\n    /**\n     * Clears out the legacy vault and removes it from the system.  Be sure to run {@link VaultMigrator.exportVault} before calling this method.\n     *\n     * @usage\n     * ```typescript\n     * const data = await migrator.exportVault();\n     * await importVault(data);\n     * await migrator.clear();\n     * ```\n     */\n    async clear() {\n        const vault = await this.migratorSession.getVault();\n        return vault.clear();\n    }\n}\n\nexport { AndroidBiometricCryptoPreference, AuthMode, BiometricSecurityStrength, BrowserVault, Device, DeviceSecurityType, SupportedBiometricType, Vault, VaultErrorCodes, VaultMigrator, VaultType };\n"]},"metadata":{},"sourceType":"module"}