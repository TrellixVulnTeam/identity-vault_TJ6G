package com.ionicframework.IdentityVault;

import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;

import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import androidx.arch.core.util.Function;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

@RequiresApi(api = Build.VERSION_CODES.M)
public class VaultManager {

    private static final HashMap<String, VaultBase> vaults = new HashMap<>();
    private AppCompatActivity activity;
    private Function<IdentityVaultConfig, Void> onConfigChangedCallback;

    public static VaultBase getVault(String key) {
        return vaults.get(key);
    }

    public void setup(IdentityVaultConfig config, Activity activity) throws VaultError {
        this.activity = (AppCompatActivity) activity;

        if (config.unlockVaultOnLoad) {
            VaultBase vault = this.getOrCreateVault(config);
            vault.appLaunched();
        }
    }

    public void clear(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config, true);
        vault.clear();
    }

    public boolean doesVaultExist(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        return vault.doesVaultExist();
    }

    public String exportVault(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        HashMap<String, String> data = vault.exportVault();
        JSONObject jsonObject = new JSONObject(data);
        return jsonObject.toString();
    }

    public String getKeys(IdentityVaultConfig config) throws VaultError {
        try {
            VaultBase vault = this.getOrCreateVault(config);
            String[] keys = vault.getKeys();
            JSONArray jsonObject = new JSONArray(keys);
            return jsonObject.toString();
        } catch (JSONException e) {
            e.printStackTrace();
            throw new VaultError("Error in getKeys");
        }
    }

    public String getValue(IdentityVaultConfig config, String key) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        return vault.getValue(key);
    }

    public IdentityVaultConfig getVaultConfig(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        return vault.config;
    }

    public void importVault(IdentityVaultConfig config, String json) throws VaultError {
        try {
            VaultBase vault = this.getOrCreateVault(config);
            HashMap<String, String> data = new HashMap<>();
            JSONObject jsonObject = new JSONObject(json);
            for (Iterator<String> it = jsonObject.keys(); it.hasNext(); ) {
                String key = it.next();
                String value = jsonObject.getString(key);
                data.put(key, value);
            }
            vault.importVault(data);
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    public boolean isLocked(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        return vault.isLocked();
    }

    public void lock(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.lock();
    }

    public void removeValue(IdentityVaultConfig config, String key) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.removeValue(key);
    }

    public void setCustomPasscode(IdentityVaultConfig config, String passcode) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.setCustomPasscode(passcode);
    }

    public void setValue(IdentityVaultConfig config, String key, String value) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.setValue(key, value);
    }

    public void unlock(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.unlock();
    }

    public void updateConfig(IdentityVaultConfig newConfig) throws VaultError {

        VaultBase oldVault = this.getOrCreateVault(newConfig);
        String passcodeFromOldVault = oldVault.customPasscode;
        if (passcodeFromOldVault == null && newConfig.type.equals("CustomPasscode")) {
            throw new MissingPasscodeError(true);
        }
        oldVault.unlock();

        HashMap<String, String> data = oldVault.exportVault();

        try {
            if (!(newConfig.type.equals("DeviceSecurity") && oldVault.config.type.equals("DeviceSecurity"))) {
                oldVault.clear();
            } else {
                oldVault.clearTypes();
            }

            VaultBase newVault = StateStore.pendingVault != null ? StateStore.pendingVault : createVault(newConfig);
            if (newVault instanceof CustomPasscodeVault) {
                newVault.customPasscode = passcodeFromOldVault;
            }

            if (newVault.config.type.equals("DeviceSecurity") && StateStore.pendingVault == null) {
                StateStore.pendingVault = newVault;
            }

            newVault.importVault(data);
            vaults.put(newVault.config.key, newVault);
            StateStore.pendingVault = null;

            if (oldVault.onLockCallback != null) {
                newVault.onLock(oldVault.onLockCallback);
            }

            if (oldVault.onUnlockCallback != null) {
                newVault.onUnlock(oldVault.onUnlockCallback);
            }

            if (this.onConfigChangedCallback != null) {
                this.onConfigChangedCallback.apply(newConfig);
            }
        } catch(VaultError error) {
            // if there was an error, keep the old vault in place
            if(passcodeFromOldVault != null) {
                oldVault.customPasscode = passcodeFromOldVault;
            }
            if(data != null) {
                oldVault.importVault(data);
            }
            vaults.put(oldVault.config.key, oldVault);
            throw error;
        }
    }

    public void onConfigChanged(Function<IdentityVaultConfig, Void> callback) {
        this.onConfigChangedCallback = callback;
    }

    public void onLock(IdentityVaultConfig config, Function<Void, Void> callback) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.onLock(callback);
    }

    public void onUnlock(IdentityVaultConfig config, Function<Void, Void> callback) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.onUnlock(callback);
    }

    protected void vaultManagerAppEnteredBackground() {
        for(Map.Entry<String, VaultBase> set : vaults.entrySet()) {
            set.getValue().backgroundEntered();
        }
    }

    protected void vaultManagerAppResumed(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.appResumed();
    }

    private VaultBase getOrCreateVault(IdentityVaultConfig config) throws VaultError {
        return this.getOrCreateVault(config, false);
    }

    private VaultBase getOrCreateVault(IdentityVaultConfig config, boolean ignoreAuth) throws VaultError {
        VaultBase vault = vaults.get(config.key);
        if (vault == null) {
            vault = createVault(config, ignoreAuth);
            vaults.put(config.key, vault);
        }
        return vault;
    }

    private VaultBase createVault(IdentityVaultConfig config) throws VaultError {
        return this.createVault(config, false);
    }

    private VaultBase createVault(IdentityVaultConfig config, boolean ignoreAuth) throws VaultError {
        VaultBase vault;

        String vaultType = VaultBase.getPersistedVaultType(config, this.activity);

        if (vaultType != null) {
            config.type = vaultType;
        }

        String vaultDeviceSecurityType = VaultBase.getPersistedVaultDeviceSecurityType(config, this.activity);
        if (vaultDeviceSecurityType != null) {
            config.deviceSecurityType = vaultDeviceSecurityType;
        }

        switch (config.type) {
            case "CustomPasscode":
                vault = new CustomPasscodeVault(config, this.activity);
                break;
            case "DeviceSecurity":
                vault = DeviceSecurityFactory.getDeviceSecurityVault(this.activity, config, Device.getInstance(), ignoreAuth);                
                break;
            case "SecureStorage":
                vault = new SecureStorageVault(config, this.activity);
                break;
            case "InMemory":
                vault = new InMemoryVault(config, this.activity);
                break;
            default:
                throw new VaultError("Vault Config type " + config.type + " is not a valid type");
        }
        return vault;
    }
}
